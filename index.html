<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Issue Tracker - Manufacturing Operations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .version {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
        }

        .sync-status {
            padding: 10px 15px;
            border-radius: 5px;
            margin: 15px 30px;
            font-size: 14px;
            display: none;
        }

        .sync-status.syncing {
            display: block;
            background: #fff3cd;
            color: #856404;
        }

        .sync-status.success {
            display: block;
            background: #d4edda;
            color: #155724;
        }

        .sync-status.error {
            display: block;
            background: #f8d7da;
            color: #721c24;
        }

        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
        }

        .nav-tab {
            flex: 1;
            padding: 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .nav-tab.active {
            background: white;
            border-bottom: 3px solid #007bff;
            color: #007bff;
            font-weight: bold;
        }

        .nav-tab:hover {
            background: #e9ecef;
        }

        .tab-content {
            display: none;
            padding: 30px;
            min-height: 600px;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .form-control {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .search-results, .history-list {
            margin-top: 20px;
        }

        .issue-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .issue-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .work-instruction {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 0;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .wi-header {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 20px 25px;
            border-radius: 12px 12px 0 0;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .wi-caution {
            background: linear-gradient(135deg, #ff9800, #ff5722);
            color: white;
            padding: 15px 25px;
            border-left: 5px solid #d84315;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }

        .wi-caution-icon {
            font-size: 28px;
            flex-shrink: 0;
        }

        .wi-metadata {
            background: #f8f9fa;
            padding: 20px 25px;
            border-bottom: 2px solid #dee2e6;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .wi-metadata-item {
            display: flex;
            flex-direction: column;
        }

        .wi-metadata-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #6c757d;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .wi-metadata-value {
            color: #2c3e50;
            font-weight: 500;
            font-size: 14px;
        }

        .wi-section {
            padding: 25px;
            border-bottom: 1px solid #e9ecef;
        }

        .wi-section:last-of-type {
            border-bottom: none;
        }

        .wi-section h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #28a745;
        }

        .wi-section h4::before {
            content: '‚ñ∂';
            color: #28a745;
            font-size: 14px;
        }

        .wi-content {
            color: #495057;
            line-height: 1.8;
            font-size: 15px;
        }

        .wi-step {
            margin: 12px 0;
            padding-left: 15px;
            position: relative;
            color: #495057;
            line-height: 1.6;
        }

        .wi-step::before {
            content: '‚óè';
            position: absolute;
            left: 0;
            color: #28a745;
            font-weight: bold;
        }

        /* Numbered steps - cleaner format */
        .wi-step.numbered {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding-left: 0;
            margin: 15px 0;
        }

        .wi-step.numbered::before {
            content: none; /* Remove bullet for numbered items */
        }

        .wi-step.numbered .step-number {
            flex-shrink: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border-radius: 50%;
            font-weight: bold;
            font-size: 14px;
        }

        .wi-step.numbered .step-text {
            flex: 1;
            padding-top: 4px;
        }

        /* Citations - subtle gray styling */
        .citation {
            color: #6c757d;
            font-size: 13px;
            font-style: italic;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 4px;
            white-space: nowrap;
        }

        /* Clean up bold text in steps */
        .wi-step strong {
            color: #2c3e50;
            font-weight: 600;
        }

        /* AI Assistance specific styles */
        .ai-assistance-content {
            line-height: 1.8;
            color: #495057;
        }

        .ai-section-header {
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
            margin: 25px 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #e9ecef;
        }

        .ai-content-line {
            margin: 10px 0;
            line-height: 1.7;
            color: #495057;
        }

        .ai-step {
            margin: 12px 0;
            padding-left: 0;
            line-height: 1.7;
        }

        /* Numbered steps in AI Assistance */
        .ai-step.numbered {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin: 15px 0;
        }

        .ai-step.numbered .step-number {
            flex-shrink: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-radius: 50%;
            font-weight: bold;
            font-size: 14px;
        }

        .ai-step.numbered .step-text {
            flex: 1;
            padding-top: 4px;
        }

        /* Strong emphasis in AI content */
        .ai-content-line strong,
        .ai-step strong {
            color: #2c3e50;
            font-weight: 600;
        }

        .wi-actions {
            padding: 25px;
            background: #f8f9fa;
            text-align: center;
            border-radius: 0 0 12px 12px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #28a745;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .action-buttons button {
            flex: 1;
            min-width: 150px;
        }

        .config-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .config-section h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .provider-selector {
            display: flex;
            gap: 15px;
            margin: 20px 0;
        }

        .provider-card {
            flex: 1;
            padding: 20px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .provider-card:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .provider-card.selected {
            border-color: #28a745;
            background: #e8f5e8;
        }

        .provider-card h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .alert-box {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .alert-success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .alert-warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .manual-list-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .manual-list-item h4 {
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .manual-list-item p {
            color: #666;
            margin: 5px 0;
            font-size: 14px;
        }

        .line-group {
            margin-bottom: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
        }

        .line-group-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 16px;
        }

        .definition-category {
            margin-bottom: 30px;
        }

        .definition-category-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .definition-item {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }

        .definition-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .definition-term {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .definition-text {
            color: #495057;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .definition-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #dee2e6;
        }

        .definition-equipment {
            font-size: 13px;
            color: #6c757d;
        }

        .definition-actions {
            display: flex;
            gap: 10px;
        }

        .definition-actions button {
            padding: 6px 12px;
            font-size: 13px;
        }

        .no-definitions {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè≠ Manufacturing Issue Tracker</h1>
            <p>Track equipment issues and generate AI-powered work instructions</p>
            <div class="version">v14.2</div>
        </div>

        <div id="sync-status" class="sync-status"></div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('report')">üìù Report Issue</button>
            <button class="nav-tab" onclick="switchTab('search')">üîç Search Issues</button>
            <button class="nav-tab" onclick="switchTab('ai')">ü§ñ AI Work Instructions</button>
            <button class="nav-tab" onclick="switchTab('history')">üìä History</button>
            <button class="nav-tab" onclick="switchTab('definitions')">üìñ Definitions</button>
            <button class="nav-tab" onclick="switchTab('settings')">‚öôÔ∏è Setup</button>
        </div>

        <div id="report-tab" class="tab-content active">
            <h2>Report New Issue</h2>
            <form id="issue-form" onsubmit="submitIssue(event)">
                <div class="form-group">
                    <label for="operator">Operator Name *</label>
                    <input type="text" id="operator" class="form-control" required>
                </div>

                <div class="form-group">
                    <label for="line">Production Line *</label>
                    <select id="line" class="form-control" required onchange="updateMachineOptions(); updateSuggestions();">
                        <option value="">Select Line</option>
                        <option value="RX500">RX500</option>
                        <option value="RX300">RX300</option>
                        <option value="HH">HH</option>
                        <option value="JBFlex">JBFlex</option>
                        <option value="L80">L80</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="machine">Machine/Equipment *</label>
                    <input type="text" id="machine" class="form-control" required list="machine-list" autocomplete="off" onchange="updateSuggestions()">
                    <datalist id="machine-list"></datalist>
                </div>

                <div class="form-group">
                    <label for="description">Issue Description *</label>
                    <input type="text" id="description" class="form-control" required list="description-suggestions" autocomplete="off">
                    <datalist id="description-suggestions"></datalist>
                    <small id="description-help" style="color: #666; font-size: 12px;">Select line and machine to see previous issues</small>
                </div>

                <div class="form-group">
                    <label>Actions Taken *</label>
                    <div id="actions-display" style="background: #f8f9fa; border: 2px dashed #dee2e6; border-radius: 8px; padding: 15px; min-height: 100px; margin-bottom: 10px;">
                        <p style="color: #999; text-align: center; margin: 20px 0;">No actions added yet. Click "Add Action" below to begin.</p>
                    </div>
                    <button type="button" class="btn btn-success" onclick="showAddActionModal()">+ Add Action</button>
                </div>

                <button type="submit" id="submit-issue-btn" class="btn btn-primary" style="display: none;">Submit Issue Report</button>
                <button type="button" id="ask-ai-btn" class="btn btn-info" style="display: none;" onclick="askAIForAssistance()">ü§ñ Ask AI For Assistance</button>
            </form>
        </div>

        <div id="search-tab" class="tab-content">
            <h2>Search Historical Issues</h2>
            
            <div class="form-group">
                <label for="search-line">Production Line</label>
                <select id="search-line" class="form-control" onchange="updateSearchMachines()">
                    <option value="">All Lines</option>
                    <option value="RX500">RX500</option>
                    <option value="RX300">RX300</option>
                    <option value="HH">HH</option>
                    <option value="JBFlex">JBFlex</option>
                    <option value="L80">L80</option>
                </select>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="search-all-lines" onchange="updateSearchMachines()" style="margin-right: 8px;">
                    <strong>Search all production lines for this machine</strong>
                </label>
                <small id="search-machine-help" style="color: #666; font-size: 12px; display: block; margin-top: 5px;">Select a production line above, or check this box to search across all lines</small>
            </div>

            <div class="form-group">
                <label for="search-machine">Machine/Equipment</label>
                <input type="text" id="search-machine" class="form-control" list="search-machine-list" autocomplete="off" onchange="updateSearchKeywords()">
                <datalist id="search-machine-list"></datalist>
            </div>

            <div class="form-group">
                <label for="search-keyword">Issue Keywords (Optional)</label>
                <input type="text" id="search-keyword" class="form-control" list="search-keyword-list" placeholder="e.g., jam, leak, error">
                <datalist id="search-keyword-list"></datalist>
                <small id="search-keyword-help" style="color: #666; font-size: 12px;">Select a machine to see previous issues</small>
            </div>

            <button onclick="searchIssues()" class="btn btn-primary">üîç Search Issues</button>

            <div id="search-results" class="search-results"></div>
        </div>

        <div id="ai-tab" class="tab-content">
            <h2><span onclick="robotEasterEgg()" style="cursor: pointer; display: inline-block; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.2) rotate(10deg)'" onmouseout="this.style.transform='scale(1) rotate(0deg)'">ü§ñ</span> AI-Generated Work Instructions</h2>
            <p style="color: #666; margin-bottom: 20px;">
                Generate detailed work instructions based on your equipment manuals and definitions. The AI will only use information from your configured manuals and will indicate when no information is available.
            </p>

            <div class="form-group">
                <label for="ai-line">Production Line *</label>
                <select id="ai-line" class="form-control" required onchange="updateAIMachines()">
                    <option value="">Select Line</option>
                    <option value="RX500">RX500</option>
                    <option value="RX300">RX300</option>
                    <option value="HH">HH</option>
                    <option value="JBFlex">JBFlex</option>
                    <option value="L80">L80</option>
                </select>
            </div>

            <div class="form-group">
                <label for="ai-machine">Machine/Equipment *</label>
                <input type="text" id="ai-machine" class="form-control" required placeholder="e.g., Heat Sealer 2" list="ai-machine-list" autocomplete="off">
                <datalist id="ai-machine-list"></datalist>
                <small id="ai-machine-help" style="color: #666; font-size: 12px; display: block; margin-top: 5px;">Select a production line above to see available machines</small>
            </div>

            <div class="form-group">
                <label for="ai-issue">How do I... *</label>
                <textarea id="ai-issue" class="form-control" rows="4" required placeholder="Describe what you need help with... (e.g., 'replace the heating element on Heat Sealer 2' or 'calibrate the tension sensor')"></textarea>
            </div>

            <button onclick="generateWorkInstruction()" class="btn btn-primary">ü§ñ Generate Work Instruction</button>

            <div id="generated-instruction"></div>
        </div>

        <div id="definitions-tab" class="tab-content">
            <h2>üìñ Definitions & Terminology</h2>
            
            <div style="background: #e8f4f8; border: 2px solid #17a2b8; border-radius: 10px; padding: 20px; margin-bottom: 20px;">
                <p style="color: #0c5460; line-height: 1.6;">
                    <strong>Manufacturing Knowledge Base:</strong> Manage definitions and terminology specific to your baby wipes production facility. 
                    These definitions are automatically included when generating AI work instructions to ensure accurate and relevant guidance.
                </p>
            </div>

            <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                <input type="text" id="definitions-search" class="form-control" placeholder="üîç Search definitions..." 
                       onkeyup="filterDefinitions()" style="flex: 1;">
                <button onclick="openDefinitionModal()" class="btn btn-success">‚ûï Add Definition</button>
            </div>

            <div id="definitions-list"></div>
        </div>

        <div id="history-tab" class="tab-content">
            <h2>Issue History</h2>
            
            <div style="margin-bottom: 20px;">
                <label for="filter-line">Filter by Line:</label>
                <select id="filter-line" class="form-control" onchange="filterHistory(); updateHistoryMachineOptions();" style="display: inline-block; width: 200px; margin: 0 10px;">
                    <option value="">All Lines</option>
                    <option value="RX500">RX500</option>
                    <option value="RX300">RX300</option>
                    <option value="HH">HH</option>
                    <option value="JBFlex">JBFlex</option>
                    <option value="L80">L80</option>
                </select>

                <label for="filter-machine">Machine:</label>
                <select id="filter-machine" class="form-control" onchange="filterHistory()" style="display: inline-block; width: 200px; margin: 0 10px;">
                    <option value="">All Machines</option>
                </select>
            </div>

            <div id="history-list" class="history-list"></div>
        </div>

        <div id="settings-tab" class="tab-content">
            <h2>‚öôÔ∏è Setup & Configuration</h2>
            
            <div class="config-section">
                <h3>ü§ñ AI Provider Selection</h3>
                <p style="color: #666; margin-bottom: 15px;">Choose which AI service to use for generating work instructions</p>
                
                <div class="provider-selector">
                    <div class="provider-card" id="gemini-card" onclick="selectProvider('gemini')">
                        <h4>üÜì Google Gemini</h4>
                        <p style="color: #666; font-size: 14px; margin: 10px 0;">FREE - No credit card needed</p>
                        <p style="color: #28a745; font-weight: bold;">‚úì Recommended for most users</p>
                    </div>
                    
                    <div class="provider-card" id="azure-card" onclick="selectProvider('azure')">
                        <h4>üíº Azure OpenAI</h4>
                        <p style="color: #666; font-size: 14px; margin: 10px 0;">Requires Azure account</p>
                        <p style="color: #007bff; font-weight: bold;">Best for enterprises</p>
                    </div>
                </div>
            </div>

            <div class="config-section" id="gemini-config">
                <h3>üîë Google Gemini Configuration</h3>
                <div class="alert-box alert-success-box">
                    <strong>‚úì FREE - No Credit Card Required</strong><br>
                    Get your free API key at: <a href="https://ai.google.dev" target="_blank">ai.google.dev</a>
                </div>

                <div class="form-group">
                    <label for="gemini-key">API Key *</label>
                    <input type="password" id="gemini-key" class="form-control" 
                           placeholder="Your Gemini API key (starts with AIza...)">
                    <small style="color: #666;">Get it from Google AI Studio (ai.google.dev) - completely free!</small>
                </div>

                <div class="form-group">
                    <label for="gemini-model">Model</label>
                    <select id="gemini-model" class="form-control">
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash (Recommended - Stable & Fast)</option>
                        <option value="gemini-1.5-pro">Gemini 1.5 Pro (More detailed, slower)</option>
                        <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash Experimental (May have limited access)</option>
                    </select>
                </div>

                <button onclick="saveGeminiConfig()" class="btn btn-primary">Save Gemini Configuration</button>
                <button onclick="testGeminiConnection()" class="btn btn-info">Test Connection</button>
            </div>

            <div class="config-section" id="azure-config" style="display: none;">
                <h3>üîë Azure OpenAI Configuration</h3>
                <div class="alert-box alert-info-box">
                    <strong>‚ÑπÔ∏è Azure Subscription Required</strong><br>
                    You'll need an Azure account with OpenAI access. New accounts get $200 free credit.
                </div>

                <div class="form-group">
                    <label for="azure-endpoint">Azure Endpoint URL *</label>
                    <input type="text" id="azure-endpoint" class="form-control" 
                           placeholder="https://your-resource.openai.azure.com/">
                    <small style="color: #666;">Found in Azure Portal ‚Üí Your OpenAI Resource ‚Üí Endpoint</small>
                </div>

                <div class="form-group">
                    <label for="azure-key">API Key *</label>
                    <input type="password" id="azure-key" class="form-control" 
                           placeholder="Your Azure OpenAI API key">
                    <small style="color: #666;">Found in Azure Portal ‚Üí Keys and Endpoint</small>
                </div>

                <div class="form-group">
                    <label for="deployment-name">Deployment Name *</label>
                    <input type="text" id="deployment-name" class="form-control" 
                           placeholder="gpt-4">
                    <small style="color: #666;">Your model deployment name (e.g., gpt-4, gpt-35-turbo)</small>
                </div>

                <button onclick="saveAzureConfig()" class="btn btn-primary">Save Azure Configuration</button>
                <button onclick="testAzureConnection()" class="btn btn-info">Test Connection</button>
                
                <div class="alert-box alert-warning-box">
                    <strong>üí∞ Azure Pricing:</strong><br>
                    ‚Ä¢ New accounts: $200 free credit<br>
                    ‚Ä¢ GPT-4: ~$0.10-$0.30 per instruction<br>
                    ‚Ä¢ GPT-3.5: ~$0.01-$0.05 per instruction
                </div>
            </div>

            <div class="config-section">
                <h3>üìö Equipment Manual Configuration</h3>
                <p style="color: #666; margin-bottom: 15px;">
                    Link each piece of equipment to its manual stored in OneDrive, SharePoint, or GitHub.
                    <strong>Manuals are organized by Production Line and Machine.</strong>
                </p>

                <div id="manual-config-list" style="margin: 15px 0;"></div>

                <div style="display: flex; gap: 10px;">
                    <button onclick="addManualMapping()" class="btn btn-success">+ Add Manual Mapping</button>
                    <button onclick="openTestPDFModal()" class="btn btn-info">üîç Test PDF Download</button>
                </div>
            </div>

            <div class="config-section">
                <h3>üîç Cloud Sync Verification</h3>
                <p style="color: #666; margin-bottom: 15px;">
                    Use these tools to verify your manual mappings are properly syncing to Google Sheets.
                </p>
                
                <button onclick="verifyCloudSync()" class="btn btn-info">üîç Check What's in Google Sheets</button>
                <button onclick="forceResyncAll()" class="btn btn-warning">üîÑ Force Re-sync All Configs</button>
                
                <div id="sync-verification-result" style="margin-top: 15px;"></div>
            </div>
        </div>

        <div id="action-modal" class="modal" onclick="handleModalClick(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <h3 style="margin-bottom: 20px; color: #2c3e50;">Add Action Taken</h3>
                
                <div class="form-group">
                    <label for="action-input">Describe the action taken: *</label>
                    <input type="text" id="action-input" class="form-control" placeholder="What did you try?" list="action-suggestions" autocomplete="off">
                    <datalist id="action-suggestions"></datalist>
                    <small id="action-help" style="color: #666; font-size: 12px;">Start typing or select from previous actions</small>
                </div>

                <div class="form-group">
                    <label>Did this action correct the problem? *</label>
                    <div class="action-buttons">
                        <button type="button" class="btn btn-success" onclick="addActionWithStatus('corrected')">
                            ‚úÖ Yes - Corrected
                        </button>
                        <button type="button" class="btn" onclick="addActionWithStatus('not-corrected')" style="background: #dc3545; color: white;">
                            ‚ùå No - Not Corrected
                        </button>
                        <button type="button" class="btn btn-warning" onclick="addActionWithStatus('unsure')">
                            ‚ùì Unsure
                        </button>
                    </div>
                </div>

                <div style="margin-top: 20px; text-align: right;">
                    <button type="button" class="btn" onclick="closeActionModal()" style="background: #6c757d; color: white;">Cancel</button>
                </div>
            </div>
        </div>

        <div id="manual-modal" class="modal" onclick="handleManualModalClick(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <h3 style="margin-bottom: 20px; color: #2c3e50;">Add Equipment Manual Mapping</h3>
                
                <div class="form-group">
                    <label for="manual-line">Production Line *</label>
                    <select id="manual-line" class="form-control" onchange="updateManualMachineOptions()">
                        <option value="">Select Production Line</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="manual-machine">Machine/Equipment *</label>
                    <input type="text" id="manual-machine" class="form-control" list="manual-machine-list" placeholder="Select or type equipment name">
                    <datalist id="manual-machine-list"></datalist>
                </div>

                <div class="form-group">
                    <label for="manual-name">Manual Name *</label>
                    <input type="text" id="manual-name" class="form-control" placeholder="e.g., Unwind Operation Manual v3.2">
                </div>

                <div class="form-group">
                    <label for="manual-url">Manual URL *</label>
                    <input type="text" id="manual-url" class="form-control" placeholder="https://drive.google.com/file/d/... (Google Drive link)">
                    <small style="color: #666; font-size: 12px;">üìÅ Paste your Google Drive link - PDF will be automatically fetched when needed</small>
                </div>

                <div style="margin-top: 20px; text-align: right;">
                    <button type="button" class="btn" onclick="closeManualModal()" style="background: #6c757d; color: white;">Cancel</button>
                    <button type="button" class="btn btn-success" onclick="saveManualMapping()">Save Manual Mapping</button>
                </div>
            </div>
        </div>

        <div id="test-pdf-modal" class="modal" onclick="handleTestPDFModalClick(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <h3 style="margin-bottom: 20px; color: #2c3e50;">üîç Test PDF Download</h3>
                
                <p style="color: #666; margin-bottom: 20px;">
                    This will test if your Google Apps Script can download PDFs from Google Drive.
                </p>
                
                <div class="form-group">
                    <label for="test-pdf-url">Google Drive PDF URL</label>
                    <input type="text" id="test-pdf-url" class="form-control" placeholder="https://drive.google.com/file/d/...">
                </div>
                
                <div id="test-pdf-result" style="margin-top: 15px;"></div>
                
                <div style="margin-top: 20px; text-align: right;">
                    <button type="button" class="btn" onclick="closeTestPDFModal()" style="background: #6c757d; color: white;">Close</button>
                    <button type="button" class="btn btn-primary" onclick="testPDFDownload()">Test Download</button>
                </div>
            </div>
        </div>

        <div id="security-modal" class="modal" onclick="handleSecurityModalClick(event)">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 400px;">
                <h3 style="margin-bottom: 20px; color: #2c3e50; text-align: center;">üîí Enter PIN</h3>
                
                <p style="color: #666; margin-bottom: 20px; text-align: center;">
                    This tab is protected. Please enter the security PIN to continue.
                </p>
                
                <div class="form-group">
                    <input type="password" id="security-pin-entry" class="form-control" 
                           placeholder="Enter PIN" maxlength="8" 
                           onkeypress="if(event.key==='Enter') checkSecurityPIN()"
                           style="text-align: center; font-size: 24px; letter-spacing: 10px; padding: 15px;">
                </div>

                <div id="security-error" style="color: #dc3545; text-align: center; margin-top: 10px; display: none;">
                    ‚ùå Incorrect PIN. Please try again.
                </div>
                
                <div style="margin-top: 20px; text-align: center;">
                    <button type="button" class="btn" onclick="closeSecurityModal()" style="background: #6c757d; color: white; margin-right: 10px;">Cancel</button>
                    <button type="button" class="btn btn-success" onclick="checkSecurityPIN()">üîì Unlock</button>
                </div>
            </div>
        </div>

        <div id="definition-modal" class="modal" onclick="handleDefinitionModalClick(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <h3 style="margin-bottom: 20px; color: #2c3e50;" id="definition-modal-title">Add Definition</h3>
                
                <div class="form-group">
                    <label for="definition-category">Category *</label>
                    <select id="definition-category" class="form-control">
                        <option value="">Select Category</option>
                        <option value="Terminology">üè∑Ô∏è Terminology</option>
                        <option value="Equipment">‚öôÔ∏è Equipment</option>
                        <option value="Issue">‚ö†Ô∏è Common Issues</option>
                        <option value="Process">üîÑ Process</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="definition-term">Term / Name *</label>
                    <input type="text" id="definition-term" class="form-control" placeholder="e.g., Substrate, Web Walk, Forming Boards">
                </div>

                <div class="form-group">
                    <label for="definition-text">Definition *</label>
                    <textarea id="definition-text" class="form-control" rows="4" placeholder="Enter the definition or description..."></textarea>
                </div>

                <div class="form-group">
                    <label for="definition-equipment">Related Equipment (Optional)</label>
                    <input type="text" id="definition-equipment" class="form-control" placeholder="e.g., Wrapper, Forming, All">
                    <small style="color: #666;">Specify which equipment this applies to, or leave blank for all</small>
                </div>

                <div style="margin-top: 20px; text-align: right;">
                    <button type="button" class="btn" onclick="closeDefinitionModal()" style="background: #6c757d; color: white;">Cancel</button>
                    <button type="button" class="btn btn-success" onclick="saveDefinition()">Save Definition</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====== CONFIGURATION ======
        // UPDATE THIS URL WHEN YOU DEPLOY A NEW VERSION OF THE GOOGLE APPS SCRIPT
        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwkP07t0Yif8o1dChDFUiuijpcFyhzoEzqI21qLb0xG75Ifte0vR0Fu517zbsOo7D_a/exec';
        
        // ====== DATA STORAGE ======
        let issues = [];
        let currentActions = []; // Track actions being added for current issue
        let azureConfig = JSON.parse(localStorage.getItem('azureConfig')) || {};
        let geminiConfig = JSON.parse(localStorage.getItem('geminiConfig')) || {};
        let manualMappings = JSON.parse(localStorage.getItem('manualMappings')) || {};
        let definitions = JSON.parse(localStorage.getItem('definitions')) || [];
        let selectedProvider = localStorage.getItem('selectedProvider') || 'gemini'; // Default to free option
        let currentEditingDefinitionId = null; // Track which definition is being edited
        
        const machinesByLine = {
            'RX500': ['Unwind', 'Festoon', 'Forming Table', 'Pull Station', 'Saw House', 'Diverter', 'Conveyor', 'Lidder', 'Wrapper', 'Case Erector', 'Case Packer', 'Weight Checker', 'Palletizer', 'Printer (Wrapper)', 'Printer (Case)'],
            'RX300': ['Unwind', 'Forming Table', 'Pull Station', 'Saw House', 'Doubler', 'Wig-Wag', 'Diverter', 'Conveyor', 'Wrapper', 'Lidder', 'Case Erector', 'Case Packer', 'Weight Checker', 'Palletizer', 'Printer (Wrapper)', 'Printer (Case)', 'Bundler'],
            'HH': ['Unwind', 'Forming Table', 'Pull Station', 'Saw House', 'Stacker', 'Conveyor', 'Wrapper', 'Lidder', 'Case Erector', 'Case Packer', 'Weight Checker', 'Palletizer', 'Printer (Wrapper)', 'Printer (Case)'],
            'JBFlex': ['Unwind', 'Forming Table', 'Pull Station', 'Saw House', 'Stacker', 'Diverter', 'Conveyor', 'Wrapper', 'Lidder', 'Case Erector', 'Case Packer', 'Weight Checker', 'Palletizer', 'Printer (Wrapper)', 'Printer (Case)'],
            'L80': ['Unwind 1', 'Unwind 2', 'Drum 1', 'Drum 2', 'Stacker 1', 'Stacker 2', 'Conveyor', 'Wrapper', 'Lidder']
        };

        // ====== INITIALIZATION ======
        window.addEventListener('load', () => {
            loadLocalData();
            loadFromCloud();
            updateHistoryMachineOptions();
            displayHistory(issues);
            loadAzureConfig();
            loadGeminiConfig();
            selectProvider(selectedProvider);
            renderManualMappings();
            initializeDefaultDefinitions();
            renderDefinitions();
        });

        // ====== CLOUD SYNC FUNCTIONS ======
        function showSyncStatus(type, message) {
            const statusDiv = document.getElementById('sync-status');
            statusDiv.className = 'sync-status ' + type;
            statusDiv.textContent = message;
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.className = 'sync-status';
                    statusDiv.textContent = '';
                }, 3000);
            }
        }

        function syncToCloud(issue) {
            return new Promise((resolve) => {
                showSyncStatus('syncing', '‚òÅÔ∏è Syncing to Google Sheets...');
                
                try {
                    let iframe = document.getElementById('sync-iframe');
                    if (!iframe) {
                        iframe = document.createElement('iframe');
                        iframe.id = 'sync-iframe';
                        iframe.name = 'sync-iframe';
                        iframe.style.display = 'none';
                        document.body.appendChild(iframe);
                    }
                    
                    let form = document.getElementById('sync-form');
                    if (form) form.remove();
                    
                    form = document.createElement('form');
                    form.id = 'sync-form';
                    form.method = 'POST';
                    form.action = GOOGLE_SCRIPT_URL;
                    form.target = 'sync-iframe';
                    form.style.display = 'none';
                    
                    const actionInput = document.createElement('input');
                    actionInput.type = 'hidden';
                    actionInput.name = 'action';
                    actionInput.value = 'save';
                    form.appendChild(actionInput);
                    
                    const issueInput = document.createElement('input');
                    issueInput.type = 'hidden';
                    issueInput.name = 'issue';
                    issueInput.value = JSON.stringify(issue);
                    form.appendChild(issueInput);
                    
                    document.body.appendChild(form);
                    form.submit();
                    
                    setTimeout(() => {
                        showSyncStatus('success', '‚úì Synced to Google Sheets successfully');
                        resolve(true);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Sync error:', error);
                    showSyncStatus('error', '‚úó Cloud sync failed - data saved locally');
                    setTimeout(() => {
                        showSyncStatus('', '');
                    }, 5000);
                    resolve(false);
                }
            });
        }

        async function loadFromCloud() {
            showSyncStatus('syncing', '‚òÅÔ∏è Loading from Google Sheets...');
            
            try {
                const response = await fetch(GOOGLE_SCRIPT_URL + '?action=load');
                const data = await response.json();
                
                if (data.success && data.issues) {
                    issues = data.issues;
                    saveLocalData();
                    
                    // Load AI configs if available
                    if (data.aiConfigs) {
                        if (data.aiConfigs.azureConfig) {
                            azureConfig = data.aiConfigs.azureConfig;
                            localStorage.setItem('azureConfig', JSON.stringify(azureConfig));
                            loadAzureConfig();
                        }
                        if (data.aiConfigs.geminiConfig) {
                            geminiConfig = data.aiConfigs.geminiConfig;
                            localStorage.setItem('geminiConfig', JSON.stringify(geminiConfig));
                            loadGeminiConfig();
                        }
                        if (data.aiConfigs.manualMappings) {
                            manualMappings = data.aiConfigs.manualMappings;
                            localStorage.setItem('manualMappings', JSON.stringify(manualMappings));
                            renderManualMappings();
                        }
                        if (data.aiConfigs.selectedProvider) {
                            selectedProvider = data.aiConfigs.selectedProvider;
                            localStorage.setItem('selectedProvider', selectedProvider);
                            selectProvider(selectedProvider);
                        }
                    }
                    
                    // Load definitions if available
                    if (data.definitions && Array.isArray(data.definitions)) {
                        definitions = data.definitions;
                        localStorage.setItem('definitions', JSON.stringify(definitions));
                        renderDefinitions();
                    }
                    
                    showSyncStatus('success', '‚úì Loaded from Google Sheets successfully');
                    
                    // Refresh current view
                    const activeTab = document.querySelector('.nav-tab.active').textContent;
                    if (activeTab.includes('History')) {
                        displayHistory(issues);
                    }
                    
                    // Update suggestions if machine is already selected
                    updateSuggestions();
                } else {
                    throw new Error('Invalid response from server');
                }
            } catch (error) {
                console.error('Load error:', error);
                showSyncStatus('error', '‚úó Failed to load from cloud - using local data');
                setTimeout(() => {
                    showSyncStatus('', '');
                }, 5000);
            }
        }

        async function syncAIConfigsToCloud() {
            return new Promise((resolve) => {
                showSyncStatus('syncing', '‚òÅÔ∏è Syncing AI configs to Google Sheets...');
                
                try {
                    let iframe = document.getElementById('sync-iframe');
                    if (!iframe) {
                        iframe = document.createElement('iframe');
                        iframe.id = 'sync-iframe';
                        iframe.name = 'sync-iframe';
                        iframe.style.display = 'none';
                        document.body.appendChild(iframe);
                    }
                    
                    let form = document.getElementById('config-sync-form');
                    if (form) form.remove();
                    
                    form = document.createElement('form');
                    form.id = 'config-sync-form';
                    form.method = 'POST';
                    form.action = GOOGLE_SCRIPT_URL;
                    form.target = 'sync-iframe';
                    form.style.display = 'none';
                    
                    const actionInput = document.createElement('input');
                    actionInput.type = 'hidden';
                    actionInput.name = 'action';
                    actionInput.value = 'saveAIConfigs';
                    form.appendChild(actionInput);
                    
                    const configsInput = document.createElement('input');
                    configsInput.type = 'hidden';
                    configsInput.name = 'aiConfigs';
                    configsInput.value = JSON.stringify({
                        azureConfig: azureConfig,
                        geminiConfig: geminiConfig,
                        manualMappings: manualMappings,
                        selectedProvider: selectedProvider
                    });
                    form.appendChild(configsInput);
                    
                    document.body.appendChild(form);
                    form.submit();
                    
                    setTimeout(() => {
                        showSyncStatus('success', '‚úì AI configs synced to Google Sheets');
                        resolve(true);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Config sync error:', error);
                    showSyncStatus('error', '‚úó Config sync failed - saved locally');
                    setTimeout(() => {
                        showSyncStatus('', '');
                    }, 5000);
                    resolve(false);
                }
            });
        }

        // ====== LOCAL STORAGE ======
        function saveLocalData() {
            localStorage.setItem('equipmentIssues', JSON.stringify(issues));
        }

        function loadLocalData() {
            const stored = localStorage.getItem('equipmentIssues');
            if (stored) {
                issues = JSON.parse(stored);
            }
        }

        // ====== UI FUNCTIONS ======
        function switchTab(tabName) {
            // Check if this is a protected tab and if security is enabled
            const protectedTabs = ['settings', 'definitions'];
            if (protectedTabs.includes(tabName) && SECURITY_ENABLED && !isAuthenticated) {
                // Store which tab was requested
                sessionStorage.setItem('requestedSecureTab', tabName + '-tab');
                
                // Show security modal
                document.getElementById('security-modal').style.display = 'flex';
                document.getElementById('security-pin-entry').value = '';
                document.getElementById('security-error').style.display = 'none';
                document.getElementById('security-pin-entry').focus();
                return; // Don't switch tabs yet
            }
            
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
            
            if (tabName === 'history') {
                displayHistory(issues);
            }
        }

        function updateMachineOptions() {
            const line = document.getElementById('line').value;
            const machineList = document.getElementById('machine-list');
            machineList.innerHTML = '';
            
            if (line && machinesByLine[line]) {
                machinesByLine[line].forEach(machine => {
                    const option = document.createElement('option');
                    option.value = machine;
                    machineList.appendChild(option);
                });
            }
        }

        function updateSuggestions() {
            const line = document.getElementById('line').value;
            const machine = document.getElementById('machine').value;
            
            const descriptionHelp = document.getElementById('description-help');
            
            // Only update if both line and machine are selected
            if (!line || !machine) {
                document.getElementById('description-suggestions').innerHTML = '';
                descriptionHelp.textContent = 'Select line and machine to see previous issues';
                return;
            }
            
            // Filter issues for this specific line + machine
            const relevantIssues = issues.filter(issue => 
                issue.line === line && 
                issue.machine.toLowerCase() === machine.toLowerCase()
            );
            
            // Extract unique descriptions
            const descriptions = new Set();
            relevantIssues.forEach(issue => {
                if (issue.description && issue.description.trim()) {
                    descriptions.add(issue.description.trim());
                }
            });
            
            // Update description datalist
            const descriptionList = document.getElementById('description-suggestions');
            descriptionList.innerHTML = '';
            descriptions.forEach(desc => {
                const option = document.createElement('option');
                option.value = desc;
                descriptionList.appendChild(option);
            });
            
            // Update helper text with counts
            if (descriptions.size > 0) {
                descriptionHelp.innerHTML = `<strong style="color: #28a745;">‚úì ${descriptions.size} previous issue${descriptions.size !== 1 ? 's' : ''} available</strong> - Start typing or click ‚ñº to select`;
            } else {
                descriptionHelp.textContent = 'No previous issues found for this machine - enter a new description';
            }
            
            // Log for debugging
            if (descriptions.size > 0) {
                console.log(`Loaded ${descriptions.size} previous issue descriptions for ${line} - ${machine}`);
            }
        }

        function updateSearchMachines() {
            const line = document.getElementById('search-line').value;
            const machineInput = document.getElementById('search-machine');
            const machineList = document.getElementById('search-machine-list');
            const allLinesCheckbox = document.getElementById('search-all-lines');
            const machineHelp = document.getElementById('search-machine-help');
            
            machineList.innerHTML = '';
            machineInput.value = '';
            
            // If "search all lines" is checked, show all unique machines
            if (allLinesCheckbox.checked) {
                const allMachines = [...new Set(issues.map(issue => issue.machine))];
                allMachines.sort().forEach(machine => {
                    const option = document.createElement('option');
                    option.value = machine;
                    machineList.appendChild(option);
                });
                machineHelp.innerHTML = `<strong style="color: #007bff;">‚ÑπÔ∏è Showing machines from all production lines</strong>`;
                allLinesCheckbox.parentElement.querySelector('strong').style.color = '#007bff';
            }
            // If a line is selected, show machines from that line
            else if (line) {
                // Show machines from machinesByLine if available
                if (machinesByLine[line]) {
                    machinesByLine[line].forEach(machine => {
                        const option = document.createElement('option');
                        option.value = machine;
                        machineList.appendChild(option);
                    });
                }
                
                // Also add machines from historical data for this line
                const historicalMachines = [...new Set(issues
                    .filter(issue => issue.line === line)
                    .map(issue => issue.machine))];
                
                historicalMachines.forEach(machine => {
                    // Only add if not already in the list
                    if (!machinesByLine[line] || !machinesByLine[line].includes(machine)) {
                        const option = document.createElement('option');
                        option.value = machine;
                        machineList.appendChild(option);
                    }
                });
                
                machineHelp.innerHTML = `<strong style="color: #28a745;">‚úì Machine suggestions loaded for ${line}</strong>`;
                allLinesCheckbox.parentElement.querySelector('strong').style.color = '#333';
            }
            // No line selected and checkbox not checked
            else {
                const allMachines = [...new Set(issues.map(issue => issue.machine))];
                allMachines.sort().forEach(machine => {
                    const option = document.createElement('option');
                    option.value = machine;
                    machineList.appendChild(option);
                });
                machineHelp.textContent = 'All machines available - select a production line to filter';
                allLinesCheckbox.parentElement.querySelector('strong').style.color = '#333';
            }
            
            // Update keyword suggestions when machine options change
            updateSearchKeywords();
        }

        function updateSearchKeywords() {
            const line = document.getElementById('search-line').value;
            const machine = document.getElementById('search-machine').value.trim();
            const allLinesCheckbox = document.getElementById('search-all-lines');
            const keywordList = document.getElementById('search-keyword-list');
            const keywordHelp = document.getElementById('search-keyword-help');
            
            keywordList.innerHTML = '';
            
            if (!machine) {
                keywordHelp.textContent = 'Select a machine to see previous issues';
                return;
            }
            
            // Filter issues based on machine and line selection
            let relevantIssues;
            if (allLinesCheckbox.checked) {
                // Search across all lines for this machine name
                relevantIssues = issues.filter(issue => 
                    issue.machine.toLowerCase() === machine.toLowerCase()
                );
            } else if (line) {
                // Search only within selected line
                relevantIssues = issues.filter(issue => 
                    issue.line === line && 
                    issue.machine.toLowerCase() === machine.toLowerCase()
                );
            } else {
                // No line selected and checkbox not checked - search all
                relevantIssues = issues.filter(issue => 
                    issue.machine.toLowerCase() === machine.toLowerCase()
                );
            }
            
            // Extract unique issue descriptions
            const descriptions = new Set();
            relevantIssues.forEach(issue => {
                if (issue.description && issue.description.trim()) {
                    descriptions.add(issue.description.trim());
                }
            });
            
            // Populate datalist
            descriptions.forEach(desc => {
                const option = document.createElement('option');
                option.value = desc;
                keywordList.appendChild(option);
            });
            
            // Update helper text
            if (descriptions.size > 0) {
                if (allLinesCheckbox.checked) {
                    const linesWithIssues = [...new Set(relevantIssues.map(issue => issue.line))];
                    keywordHelp.innerHTML = `<strong style="color: #007bff;">‚ÑπÔ∏è ${descriptions.size} previous issue${descriptions.size !== 1 ? 's' : ''} found across ${linesWithIssues.length} production line${linesWithIssues.length !== 1 ? 's' : ''}</strong> - Click ‚ñº to select`;
                } else if (line) {
                    keywordHelp.innerHTML = `<strong style="color: #28a745;">‚úì ${descriptions.size} previous issue${descriptions.size !== 1 ? 's' : ''} found for ${machine} on ${line}</strong> - Click ‚ñº to select`;
                } else {
                    keywordHelp.innerHTML = `<strong style="color: #28a745;">‚úì ${descriptions.size} previous issue${descriptions.size !== 1 ? 's' : ''} found for ${machine}</strong> - Click ‚ñº to select`;
                }
            } else {
                keywordHelp.innerHTML = `<span style="color: #dc3545;">No previous issues found for this machine</span>`;
            }
        }

        function updateAIMachines() {
            const line = document.getElementById('ai-line').value;
            const machineInput = document.getElementById('ai-machine');
            const machineList = document.getElementById('ai-machine-list');
            const machineHelp = document.getElementById('ai-machine-help');
            
            machineList.innerHTML = '';
            machineInput.value = '';
            
            if (line) {
                // Show machines from machinesByLine if available
                if (machinesByLine[line]) {
                    machinesByLine[line].forEach(machine => {
                        const option = document.createElement('option');
                        option.value = machine;
                        machineList.appendChild(option);
                    });
                }
                
                // Also add machines from historical data for this line
                const historicalMachines = [...new Set(issues
                    .filter(issue => issue.line === line)
                    .map(issue => issue.machine))];
                
                historicalMachines.forEach(machine => {
                    // Only add if not already in the list
                    if (!machinesByLine[line] || !machinesByLine[line].includes(machine)) {
                        const option = document.createElement('option');
                        option.value = machine;
                        machineList.appendChild(option);
                    }
                });
                
                machineHelp.innerHTML = `<strong style="color: #28a745;">‚úì Machine suggestions loaded for ${line}</strong> - Click ‚ñº to select`;
            } else {
                machineHelp.textContent = 'Select a production line above to see available machines';
            }
        }

        function updateHistoryMachineOptions() {
            const line = document.getElementById('filter-line').value;
            const machineSelect = document.getElementById('filter-machine');
            
            machineSelect.innerHTML = '<option value="">All Machines</option>';
            
            if (line) {
                const machines = [...new Set(issues
                    .filter(issue => issue.line === line)
                    .map(issue => issue.machine))];
                
                machines.sort().forEach(machine => {
                    const option = document.createElement('option');
                    option.value = machine;
                    option.textContent = machine;
                    machineSelect.appendChild(option);
                });
            } else {
                const machines = [...new Set(issues.map(issue => issue.machine))];
                machines.sort().forEach(machine => {
                    const option = document.createElement('option');
                    option.value = machine;
                    option.textContent = machine;
                    machineSelect.appendChild(option);
                });
            }
        }

        // ====== ACTION MANAGEMENT ======
        function showAddActionModal() {
            // Update action suggestions based on current selections
            const line = document.getElementById('line').value;
            const machine = document.getElementById('machine').value;
            const description = document.getElementById('description').value;
            
            if (!line || !machine || !description) {
                alert('Please fill in Production Line, Machine, and Issue Description first.');
                return;
            }
            
            // Load previous actions for suggestions
            const relevantIssues = issues.filter(issue => 
                issue.line === line && 
                issue.machine.toLowerCase() === machine.toLowerCase() &&
                issue.description.toLowerCase().includes(description.toLowerCase())
            );
            
            const actions = new Set();
            relevantIssues.forEach(issue => {
                if (issue.solutions && issue.solutions.trim()) {
                    actions.add(issue.solutions.trim());
                }
            });
            
            // Update action suggestions datalist
            const actionList = document.getElementById('action-suggestions');
            actionList.innerHTML = '';
            actions.forEach(action => {
                const option = document.createElement('option');
                option.value = action;
                actionList.appendChild(option);
            });
            
            // Update helper text
            const actionHelp = document.getElementById('action-help');
            if (actions.size > 0) {
                actionHelp.innerHTML = `<strong style="color: #28a745;">‚úì ${actions.size} previous action${actions.size !== 1 ? 's' : ''} available</strong> - Start typing or click ‚ñº to select`;
            } else {
                actionHelp.textContent = 'No previous actions found - enter a new action';
            }
            
            // Show modal
            document.getElementById('action-modal').style.display = 'block';
            document.getElementById('action-input').focus();
        }

        function closeActionModal() {
            document.getElementById('action-modal').style.display = 'none';
            document.getElementById('action-input').value = '';
        }

        function handleModalClick(event) {
            if (event.target.id === 'action-modal') {
                closeActionModal();
            }
        }

        function addActionWithStatus(status) {
            const action = document.getElementById('action-input').value.trim();
            
            if (!action) {
                alert('Please describe the action taken.');
                return;
            }
            
            // Map status to match Python version naming
            const statusMap = {
                'corrected': 'Corrected',
                'not-corrected': 'Not Corrected',
                'unsure': 'Unsure'
            };
            
            // Add action to current actions array
            currentActions.push({
                action: action,
                status: statusMap[status],
                timestamp: new Date().toISOString()
            });
            
            // Update display
            updateActionsDisplay();
            
            // Close modal
            closeActionModal();
            
            // Ask if they want to add another action
            setTimeout(() => {
                const addAnother = confirm('Action added successfully!\n\nWould you like to add another action?');
                if (addAnother) {
                    showAddActionModal();
                } else {
                    // Show submit button and AI assistance button now that we have at least one action
                    document.getElementById('submit-issue-btn').style.display = 'inline-block';
                    document.getElementById('ask-ai-btn').style.display = 'inline-block';
                }
            }, 100);
        }
        
        function updateActionsDisplay() {
            const display = document.getElementById('actions-display');
            
            if (currentActions.length === 0) {
                display.innerHTML = '<p style="color: #999; text-align: center; margin: 20px 0;">No actions added yet. Click "Add Action" below to begin.</p>';
            } else {
                let html = '<div style="padding: 5px;">';
                currentActions.forEach((act, index) => {
                    const statusEmoji = act.status === 'Corrected' ? '‚úÖ' : 
                                       act.status === 'Not Corrected' ? '‚ùå' : '‚ùì';
                    const statusColor = act.status === 'Corrected' ? '#28a745' : 
                                       act.status === 'Not Corrected' ? '#dc3545' : '#ffc107';
                    
                    html += `
                        <div style="background: white; border-left: 4px solid ${statusColor}; padding: 12px; margin-bottom: 10px; border-radius: 5px;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <strong>${index + 1}. ${act.action}</strong>
                                    <div style="margin-top: 5px; font-size: 14px; color: #666;">
                                        Status: ${statusEmoji} <span style="color: ${statusColor}; font-weight: bold;">${act.status}</span>
                                    </div>
                                </div>
                                <button onclick="removeAction(${index})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 12px;">Remove</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                display.innerHTML = html;
            }
        }
        
        function removeAction(index) {
            if (confirm('Are you sure you want to remove this action?')) {
                currentActions.splice(index, 1);
                updateActionsDisplay();
                
                // Hide submit button and AI button if no actions remain
                if (currentActions.length === 0) {
                    document.getElementById('submit-issue-btn').style.display = 'none';
                    document.getElementById('ask-ai-btn').style.display = 'none';
                }
            }
        }

        // ====== FORM SUBMISSION ======
        async function submitIssue(event) {
            event.preventDefault();
            
            // Validate that at least one action has been added
            if (currentActions.length === 0) {
                alert('Please add at least one action taken before submitting.');
                return;
            }
            
            const operator = document.getElementById('operator').value;
            const line = document.getElementById('line').value;
            const machine = document.getElementById('machine').value;
            const description = document.getElementById('description').value;
            
            // Create a separate issue entry for each action (matching Python version)
            const newIssues = [];
            for (const act of currentActions) {
                const issue = {
                    id: Date.now().toString() + '-' + Math.random().toString(36).substr(2, 9),
                    timestamp: act.timestamp,
                    operator: operator,
                    line: line,
                    machine: machine,
                    description: description,
                    solutions: act.action,
                    effectiveness: act.status.toLowerCase().replace(' ', '-')
                };
                
                newIssues.push(issue);
                issues.push(issue);
            }
            
            saveLocalData();
            
            // Sync all new issues to cloud
            for (const issue of newIssues) {
                await syncToCloud(issue);
            }
            
            alert('Issue logged successfully with ' + currentActions.length + ' action(s)!');
            
            // Reset form and actions
            document.getElementById('issue-form').reset();
            currentActions = [];
            updateActionsDisplay();
            document.getElementById('submit-issue-btn').style.display = 'none';
            document.getElementById('ask-ai-btn').style.display = 'none';
            
            // Clear AI assistance display if it exists
            const aiAssistanceDiv = document.getElementById('ai-assistance-display');
            if (aiAssistanceDiv) {
                aiAssistanceDiv.innerHTML = '';
            }
        }

        // ====== SEARCH FUNCTIONS ======
        function searchIssues() {
            const line = document.getElementById('search-line').value;
            const machine = document.getElementById('search-machine').value.toLowerCase().trim();
            const keyword = document.getElementById('search-keyword').value.toLowerCase().trim();
            const searchAllLines = document.getElementById('search-all-lines').checked;
            
            const results = issues.filter(issue => {
                // If "search all lines" is checked, ignore the line filter for machine matching
                let matchLine;
                if (searchAllLines && machine) {
                    // When searching all lines for a specific machine, ignore line selection
                    matchLine = true;
                } else {
                    // Normal line filtering
                    matchLine = !line || issue.line === line;
                }
                
                const matchMachine = !machine || issue.machine.toLowerCase().includes(machine);
                const matchKeyword = !keyword || 
                    issue.description.toLowerCase().includes(keyword) ||
                    (issue.solutions && issue.solutions.toLowerCase().includes(keyword));
                
                return matchLine && matchMachine && matchKeyword;
            });
            
            displaySearchResults(results, searchAllLines);
        }

        function analyzeSolutions(results) {
            // Group solutions by text and track effectiveness
            const solutionStats = {};
            
            results.forEach(issue => {
                if (issue.solutions && issue.solutions.trim()) {
                    // Normalize solution text for grouping
                    const normalized = issue.solutions.trim()
                        .toLowerCase()
                        .replace(/[.,!?;:]+$/, '')  // Remove trailing punctuation
                        .replace(/\s+/g, ' ')        // Normalize spaces
                        .trim();
                    
                    if (!solutionStats[normalized]) {
                        solutionStats[normalized] = {
                            text: issue.solutions.trim().replace(/[.,!?;:]+$/, ''), // Clean version for display
                            total: 0,
                            corrected: 0,
                            notCorrected: 0,
                            unsure: 0
                        };
                    }
                    
                    solutionStats[normalized].total++;
                    
                    if (issue.effectiveness === 'corrected') {
                        solutionStats[normalized].corrected++;
                    } else if (issue.effectiveness === 'not-corrected') {
                        solutionStats[normalized].notCorrected++;
                    } else if (issue.effectiveness === 'unsure') {
                        solutionStats[normalized].unsure++;
                    }
                }
            });
            
            // Convert to array and calculate success rate
            const solutionArray = Object.values(solutionStats).map(stat => {
                // Option B: Ignore "unsure" - only use known outcomes (corrected + not corrected)
                const knownOutcomes = stat.corrected + stat.notCorrected;
                
                if (knownOutcomes > 0) {
                    stat.successRate = (stat.corrected / knownOutcomes) * 100;
                } else {
                    // If only "unsure" results, set to -1 to indicate unknown
                    stat.successRate = -1;
                }
                
                return stat;
            });
            
            // Sort by success rate (descending) then by total attempts (descending)
            solutionArray.sort((a, b) => {
                // First, put unknown rates at the end
                if (a.successRate === -1 && b.successRate !== -1) return 1;
                if (a.successRate !== -1 && b.successRate === -1) return -1;
                if (a.successRate === -1 && b.successRate === -1) {
                    return b.total - a.total; // Sort by attempts if both unknown
                }
                
                // Then sort by success rate
                if (Math.abs(a.successRate - b.successRate) > 0.1) {
                    return b.successRate - a.successRate;
                }
                
                // If success rates are similar, sort by total attempts
                return b.total - a.total;
            });
            
            return solutionArray;
        }

        function displaySearchResults(results, searchAllLines = false) {
            const container = document.getElementById('search-results');
            
            if (results.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">No matching issues found.</p>';
                return;
            }
            
            // Calculate and display solution effectiveness analysis
            const solutionAnalysis = analyzeSolutions(results);
            
            let html = `
                <div style="background: linear-gradient(135deg, #e8f4f8, #f0f8ff); border: 2px solid #007bff; border-radius: 10px; padding: 20px; margin: 20px 0;">
                    <h3 style="color: #007bff; margin-bottom: 15px;">üìä Solution Effectiveness Analysis</h3>
                    <p style="color: #666; margin-bottom: 15px;">Found <strong>${results.length}</strong> matching issue${results.length !== 1 ? 's' : ''}. Here are the most effective solutions:</p>
            `;
            
            if (solutionAnalysis.length > 0) {
                html += '<div style="margin-top: 15px;">';
                solutionAnalysis.slice(0, 5).forEach((stat, index) => {
                    const successColor = stat.successRate >= 70 ? '#28a745' : 
                                       stat.successRate >= 40 ? '#ffc107' : 
                                       stat.successRate >= 0 ? '#dc3545' : '#6c757d';
                    
                    const successText = stat.successRate >= 0 
                        ? `${stat.successRate.toFixed(0)}% success rate` 
                        : 'Success rate unknown';
                    
                    const rankEmoji = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                    
                    html += `
                        <div style="background: white; border-left: 4px solid ${successColor}; padding: 12px; margin-bottom: 10px; border-radius: 5px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <strong style="color: #2c3e50;">${rankEmoji} ${stat.text}</strong>
                                <span style="background: ${successColor}; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                                    ${successText}
                                </span>
                            </div>
                            <div style="font-size: 13px; color: #666;">
                                Tried <strong>${stat.total}</strong> time${stat.total !== 1 ? 's' : ''}: 
                                <span style="color: #28a745;">‚úÖ ${stat.corrected}</span> | 
                                <span style="color: #dc3545;">‚ùå ${stat.notCorrected}</span>
                                ${stat.unsure > 0 ? ` | <span style="color: #ffc107;">‚ùì ${stat.unsure}</span>` : ''}
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += '<p style="color: #666;">No solution effectiveness data available yet.</p>';
            }
            
            html += '</div>';
            
            // Display individual issue cards
            html += '<h3 style="margin-top: 30px; color: #2c3e50;">Individual Issue Reports:</h3>';
            
            // Group issues by line if searching all lines
            if (searchAllLines) {
                const issuesByLine = {};
                results.forEach(issue => {
                    if (!issuesByLine[issue.line]) {
                        issuesByLine[issue.line] = [];
                    }
                    issuesByLine[issue.line].push(issue);
                });
                
                Object.keys(issuesByLine).sort().forEach(line => {
                    html += `
                        <h4 style="margin-top: 20px; color: #667eea; background: #f8f9fa; padding: 10px; border-radius: 5px;">
                            ${line} (${issuesByLine[line].length} issue${issuesByLine[line].length !== 1 ? 's' : ''})
                        </h4>
                    `;
                    
                    issuesByLine[line].forEach(issue => {
                        html += formatIssueCard(issue);
                    });
                });
            } else {
                results.forEach(issue => {
                    html += formatIssueCard(issue);
                });
            }
            
            container.innerHTML = html;
        }

        function formatIssueCard(issue) {
            let effectivenessHTML = '';
            if (issue.effectiveness) {
                const effectivenessMap = {
                    'corrected': '<span style="color: #28a745; font-weight: bold;">‚úÖ Corrected</span>',
                    'not-corrected': '<span style="color: #dc3545; font-weight: bold;">‚ùå Not Corrected</span>',
                    'unsure': '<span style="color: #ffc107; font-weight: bold;">‚ùì Unsure</span>'
                };
                effectivenessHTML = ` | <strong>Effectiveness:</strong> ${effectivenessMap[issue.effectiveness]}`;
            }
            
            return `
                <div class="issue-card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4>${issue.line} - ${issue.machine}</h4>
                        <small style="color: #666;">${new Date(issue.timestamp).toLocaleDateString()}</small>
                    </div>
                    <p><strong>Issue:</strong> ${issue.description}</p>
                    <p><strong>Solutions Tried:</strong> ${issue.solutions || 'None documented'}</p>
                    <p><strong>Operator:</strong> ${issue.operator}${effectivenessHTML}</p>
                </div>
            `;
        }

        function displayHistory(issuesToDisplay) {
            const container = document.getElementById('history-list');
            
            if (issuesToDisplay.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">No issues logged yet.</p>';
                return;
            }
            
            const html = issuesToDisplay.slice().reverse().map(issue => {
                return formatIssueCard(issue);
            }).join('');
            
            container.innerHTML = html;
        }

        function filterHistory() {
            const line = document.getElementById('filter-line').value;
            const machine = document.getElementById('filter-machine').value;
            
            let filtered = issues;
            
            if (line) {
                filtered = filtered.filter(issue => issue.line === line);
            }
            
            if (machine) {
                filtered = filtered.filter(issue => issue.machine === machine);
            }
            
            displayHistory(filtered);
        }

        // ====== AI PROVIDER SELECTION ======
        function selectProvider(provider) {
            selectedProvider = provider;
            localStorage.setItem('selectedProvider', provider);
            
            // Update UI
            document.getElementById('gemini-card').classList.remove('selected');
            document.getElementById('azure-card').classList.remove('selected');
            document.getElementById(provider + '-card').classList.add('selected');
            
            // Show/hide config sections
            const geminiConfig = document.getElementById('gemini-config');
            const azureConfig = document.getElementById('azure-config');
            if (geminiConfig) geminiConfig.style.display = provider === 'gemini' ? 'block' : 'none';
            if (azureConfig) azureConfig.style.display = provider === 'azure' ? 'block' : 'none';
            
            // Sync to cloud
            syncAIConfigsToCloud();
        }

        // ====== GOOGLE GEMINI API ======
        // SIMPLIFIED: Reverted to a single, direct API call
        async function callGeminiAPI(prompt, fileUris = null) {
            const apiKey = geminiConfig.apiKey;
            // Use stable, widely available model
            const model = geminiConfig.model || 'gemini-1.5-flash';
            
            // Use v1beta for file support, v1 for text-only
            const endpoint = fileUris ? 'v1beta' : 'v1';
            const url = `https://generativelanguage.googleapis.com/${endpoint}/models/${model}:generateContent?key=${apiKey}`;
            
            // Build parts array - include files if provided
            const parts = [];
            
            // Add files first if provided (so AI reads them before the prompt)
            // Handle both old single URI format and new array format
            if (fileUris) {
                if (Array.isArray(fileUris)) {
                    // New format: array of {uri, name} objects
                    fileUris.forEach(fileData => {
                        parts.push({
                            fileData: {
                                mimeType: 'application/pdf',
                                fileUri: fileData.uri
                            }
                        });
                    });
                } else {
                    // Old format: single URI string (for backward compatibility)
                    parts.push({
                        fileData: {
                            mimeType: 'application/pdf',
                            fileUri: fileUris
                        }
                    });
                }
            }
            
            // Add text prompt
            parts.push({
                text: prompt
            });
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [{
                        parts: parts
                    }],
                    generationConfig: {
                        temperature: 0.7,
                        maxOutputTokens: 2048
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                let errorMsg = errorData.error?.message || `API request failed with status ${response.status}`;
                
                // Provide helpful guidance for common errors
                if (errorMsg.includes('quota') || errorMsg.includes('Quota')) {
                    errorMsg += '\n\n‚ö†Ô∏è QUOTA EXCEEDED - Your API key is blocked.\n\n' +
                               '‚úì SOLUTION: Generate a FRESH API key:\n' +
                               '1. Visit: https://aistudio.google.com/app/apikey\n' +
                               '2. Click "Create API Key"\n' +
                               '3. Copy the NEW key and paste it in Setup tab\n\n' +
                               'OR switch to Azure OpenAI provider (dropdown above)';
                } else if (errorMsg.includes('API key not valid')) {
                    errorMsg += '\n\n‚ö†Ô∏è INVALID KEY\n\nGenerate a new one at:\nhttps://aistudio.google.com/app/apikey';
                }
                
                throw new Error(errorMsg);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        function loadGeminiConfig() {
            const keyInput = document.getElementById('gemini-key');
            const modelSelect = document.getElementById('gemini-model');
            if (keyInput && geminiConfig.apiKey) {
                keyInput.value = geminiConfig.apiKey;
            }
            if (modelSelect && geminiConfig.model) {
                modelSelect.value = geminiConfig.model;
            }
        }

        function saveGeminiConfig() {
            const keyInput = document.getElementById('gemini-key');
            const modelSelect = document.getElementById('gemini-model');
            geminiConfig = {
                apiKey: keyInput ? keyInput.value : '',
                // Use stable, widely available model
                model: modelSelect ? modelSelect.value : 'gemini-1.5-flash'
            };
            
            localStorage.setItem('geminiConfig', JSON.stringify(geminiConfig));
            syncAIConfigsToCloud();
            alert('‚úì Google Gemini configuration saved and synced to cloud!');
        }

        // SIMPLIFIED: Reverted test connection to a single attempt
        async function testGeminiConnection() {
            if (!geminiConfig.apiKey) {
                alert('Please save your Gemini API key first');
                return;
            }

            try {
                // Call the API directly using the simplified function logic
                const response = await callGeminiAPI('Hello! Please respond with "Connection successful!"');
                alert('‚úì Connection successful!\n\n' + response);

            } catch (error) {
                alert('‚ùå Connection failed:\n\n' + error.message);
            }
        }

        // ====== AZURE OPENAI API ======
        async function callAzureOpenAI(prompt) {
            const endpoint = azureConfig.endpoint.replace(/\/$/, '');
            const deploymentName = azureConfig.deploymentName || 'gpt-4';
            const apiVersion = '2024-02-15-preview';
            
            const url = `${endpoint}/openai/deployments/${deploymentName}/chat/completions?api-version=${apiVersion}`;
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'api-key': azureConfig.apiKey
                },
                body: JSON.stringify({
                    messages: [
                        {
                            role: 'system',
                            content: 'You are an expert manufacturing technician and technical writer who creates clear, detailed work instructions for equipment troubleshooting.'
                        },
                        {
                            role: 'user',
                            content: prompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 2000
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        function loadAzureConfig() {
            const endpointInput = document.getElementById('azure-endpoint');
            const keyInput = document.getElementById('azure-key');
            const deploymentInput = document.getElementById('deployment-name');
            
            if (endpointInput && azureConfig.endpoint) {
                endpointInput.value = azureConfig.endpoint;
            }
            if (keyInput && azureConfig.apiKey) {
                keyInput.value = azureConfig.apiKey;
            }
            if (deploymentInput && azureConfig.deploymentName) {
                deploymentInput.value = azureConfig.deploymentName;
            }
        }

        function saveAzureConfig() {
            const endpointInput = document.getElementById('azure-endpoint');
            const keyInput = document.getElementById('azure-key');
            const deploymentInput = document.getElementById('deployment-name');
            
            azureConfig = {
                endpoint: endpointInput ? endpointInput.value : '',
                apiKey: keyInput ? keyInput.value : '',
                deploymentName: deploymentInput ? deploymentInput.value : 'gpt-4'
            };
            
            localStorage.setItem('azureConfig', JSON.stringify(azureConfig));
            syncAIConfigsToCloud();
            alert('‚úì Azure OpenAI configuration saved and synced to cloud!');
        }

        async function testAzureConnection() {
            if (!azureConfig.endpoint || !azureConfig.apiKey) {
                alert('Please save your Azure configuration first');
                return;
            }

            try {
                const response = await callAzureOpenAI('Hello! Please respond with "Connection successful!"');
                alert('‚úì Connection successful!\n\n' + response);
            } catch (error) {
                alert('‚ùå Connection failed:\n\n' + error.message);
            }
        }

        // ====== MANUAL MAPPINGS ======
        function renderManualMappings() {
            const container = document.getElementById('manual-config-list');
            if (!container) return;
            
            if (Object.keys(manualMappings).length === 0) {
                container.innerHTML = '<p style="color: #666; font-style: italic;">No manual mappings configured yet.</p>';
                return;
            }

            // Group by production line
            const manualsByLine = {};
            for (const [key, manualsArray] of Object.entries(manualMappings)) {
                // key format is "LINE-MACHINE"
                const [line, machine] = key.split('-', 2);
                if (!manualsByLine[line]) {
                    manualsByLine[line] = [];
                }
                
                // Handle both old single-object format and new array format for migration
                const manuals = Array.isArray(manualsArray) ? manualsArray : [manualsArray];
                
                manualsByLine[line].push({ key, line, machine, manuals });
            }

            let html = '';
            
            // Render each line group
            for (const [line, equipmentList] of Object.entries(manualsByLine).sort()) {
                const totalManuals = equipmentList.reduce((sum, eq) => sum + eq.manuals.length, 0);
                html += `
                    <div class="line-group">
                        <div class="line-group-header">
                            ${line} (${equipmentList.length} equipment, ${totalManuals} manual${totalManuals !== 1 ? 's' : ''})
                        </div>
                `;
                
                equipmentList.forEach(({ key, machine, manuals }) => {
                    html += `
                        <div class="manual-list-item">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <h4 style="margin: 0; color: #2c3e50;">${machine}</h4>
                                <button onclick="addManualMapping('${key}')" class="btn btn-success" style="padding: 6px 12px; font-size: 13px;">
                                    ‚ûï Add Manual
                                </button>
                            </div>
                    `;
                    
                    // Display each manual for this equipment
                    manuals.forEach((manual, index) => {
                        // Determine cache status
                        const hasPDF = manual.geminiFileUri ? true : false;
                        const needsRefresh = manual.lastUpdated ? needsCacheRefresh(manual.lastUpdated) : true;
                        const lastUpdatedText = manual.lastUpdated 
                            ? new Date(manual.lastUpdated).toLocaleDateString() 
                            : 'Never';
                        
                        let statusBadge = '';
                        if (hasPDF && !needsRefresh) {
                            statusBadge = '<span style="background: #28a745; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">‚úÖ PDF Cached</span>';
                        } else if (hasPDF && needsRefresh) {
                            statusBadge = '<span style="background: #ffc107; color: #212529; padding: 4px 8px; border-radius: 4px; font-size: 12px;">‚ö†Ô∏è Needs Refresh</span>';
                        } else {
                            statusBadge = '<span style="background: #6c757d; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">üìÑ Not Cached</span>';
                        }
                        
                        html += `
                            <div style="background: ${index % 2 === 0 ? '#f8f9fa' : '#ffffff'}; border: 1px solid #dee2e6; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <p style="margin: 0 0 8px 0;"><strong>üìò ${manual.name}</strong> ${statusBadge}</p>
                                        <p style="margin: 0 0 5px 0; font-size: 13px;"><strong>URL:</strong> <a href="${manual.url}" target="_blank" style="color: #007bff; word-break: break-all;">${manual.url}</a></p>
                                        <p style="margin: 0; font-size: 12px; color: #666;"><strong>Last Updated:</strong> ${lastUpdatedText}</p>
                                    </div>
                                    <div style="display: flex; gap: 5px; margin-left: 10px;">
                                        <button onclick="refreshSingleManual('${key}', '${manual.id}')" class="btn btn-info" style="padding: 6px 12px; font-size: 13px;" title="Refresh PDF from Google Drive">
                                            üîÑ
                                        </button>
                                        <button onclick="removeManualMapping('${key}', '${manual.id}')" class="btn" style="background: #dc3545; color: white; padding: 6px 12px; font-size: 13px;">
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                });
                
                html += '</div>';
            }
            
            container.innerHTML = html;
        }

        function addManualMapping(prefillKey = null) {
            // Populate line dropdown
            const lineSelect = document.getElementById('manual-line');
            lineSelect.innerHTML = '<option value="">Select Production Line</option>';
            
            // Get unique lines from machinesByLine and historical data
            const allLines = new Set(Object.keys(machinesByLine));
            issues.forEach(issue => allLines.add(issue.line));
            
            Array.from(allLines).sort().forEach(line => {
                const option = document.createElement('option');
                option.value = line;
                option.textContent = line;
                lineSelect.appendChild(option);
            });
            
            // Pre-fill if adding to existing equipment
            if (prefillKey) {
                const [line, machine] = prefillKey.split('-', 2);
                lineSelect.value = line;
                updateManualMachineOptions();
                document.getElementById('manual-machine').value = machine;
                document.getElementById('manual-name').value = '';
                document.getElementById('manual-url').value = '';
            } else {
                // Clear form
                document.getElementById('manual-machine').value = '';
                document.getElementById('manual-name').value = '';
                document.getElementById('manual-url').value = '';
            }
            
            // Show modal
            document.getElementById('manual-modal').style.display = 'block';
        }

        function updateManualMachineOptions() {
            const line = document.getElementById('manual-line').value;
            const machineList = document.getElementById('manual-machine-list');
            
            machineList.innerHTML = '';
            
            if (!line) return;
            
            // Get machines from predefined list
            const machines = new Set();
            if (machinesByLine[line]) {
                machinesByLine[line].forEach(m => machines.add(m));
            }
            
            // Add machines from historical data
            issues
                .filter(issue => issue.line === line)
                .forEach(issue => machines.add(issue.machine));
            
            // Populate datalist
            Array.from(machines).sort().forEach(machine => {
                const option = document.createElement('option');
                option.value = machine;
                machineList.appendChild(option);
            });
        }

        function closeManualModal() {
            document.getElementById('manual-modal').style.display = 'none';
        }

        function handleManualModalClick(event) {
            if (event.target.id === 'manual-modal') {
                closeManualModal();
            }
        }

        // ====== GOOGLE DRIVE & GEMINI FILE API HELPERS ======
        
        // Convert Google Drive view link to direct download link
        function convertGoogleDriveUrl(url) {
            // Extract file ID from various Google Drive URL formats
            let fileId = null;
            
            // Format 1: https://drive.google.com/file/d/FILE_ID/view
            const viewMatch = url.match(/\/file\/d\/([^\/]+)/);
            if (viewMatch) {
                fileId = viewMatch[1];
            }
            
            // Format 2: https://drive.google.com/open?id=FILE_ID
            const openMatch = url.match(/[?&]id=([^&]+)/);
            if (openMatch) {
                fileId = openMatch[1];
            }
            
            if (fileId) {
                return `https://drive.google.com/uc?export=download&id=${fileId}`;
            }
            
            // If already a direct link or not a Google Drive link, return as-is
            return url;
        }
        
        // Download PDF from Google Drive via Google Apps Script proxy
        async function downloadPDFFromGoogleDrive(url) {
            if (!GOOGLE_SCRIPT_URL) {
                throw new Error('Google Apps Script URL not configured. Please set it in the Setup tab.');
            }
            
            try {
                // Call Google Apps Script to download the PDF
                const scriptUrl = `${GOOGLE_SCRIPT_URL}?action=downloadPDF&url=${encodeURIComponent(url)}`;
                
                const response = await fetch(scriptUrl);
                if (!response.ok) {
                    throw new Error(`Failed to download PDF: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.message || 'Failed to download PDF');
                }
                
                // Convert base64 back to blob
                const binaryString = atob(data.data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                const blob = new Blob([bytes], { type: data.mimeType || 'application/pdf' });
                return blob;
            } catch (error) {
                console.error('Error downloading PDF via Google Apps Script:', error);
                throw new Error('Failed to download PDF from Google Drive. Please check the link is accessible and Google Apps Script is configured correctly.');
            }
        }
        
        // Upload PDF to Gemini File API
        async function uploadPDFToGemini(pdfBlob, fileName) {
            if (!geminiConfig.apiKey) {
                throw new Error('Gemini API key not configured');
            }
            
            // Step 1: Start resumable upload session
            const initialMetadata = {
                file: {
                    display_name: fileName
                }
            };
            
            const initResponse = await fetch(
                `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${geminiConfig.apiKey}`,
                {
                    method: 'POST',
                    headers: {
                        'X-Goog-Upload-Protocol': 'resumable',
                        'X-Goog-Upload-Command': 'start',
                        'X-Goog-Upload-Header-Content-Type': 'application/pdf',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(initialMetadata)
                }
            );
            
            if (!initResponse.ok) {
                throw new Error(`Failed to start upload: ${initResponse.status}`);
            }
            
            const uploadUrl = initResponse.headers.get('X-Goog-Upload-URL');
            if (!uploadUrl) {
                throw new Error('No upload URL received from Gemini');
            }
            
            // Step 2: Upload the actual file
            const uploadResponse = await fetch(uploadUrl, {
                method: 'POST',
                headers: {
                    'X-Goog-Upload-Command': 'upload, finalize',
                    'X-Goog-Upload-Offset': '0',
                    'Content-Type': 'application/pdf'
                },
                body: pdfBlob
            });
            
            if (!uploadResponse.ok) {
                const errorText = await uploadResponse.text();
                console.error('Upload error:', errorText);
                throw new Error(`Failed to upload PDF: ${uploadResponse.status}`);
            }
            
            const fileData = await uploadResponse.json();
            
            // Step 3: Wait for file to be processed (Gemini needs time to process PDFs)
            let file = fileData.file;
            while (file.state === 'PROCESSING') {
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                
                const statusResponse = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/${file.name}?key=${geminiConfig.apiKey}`
                );
                
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    file = statusData;
                } else {
                    break;
                }
            }
            
            if (file.state !== 'ACTIVE') {
                throw new Error('PDF processing failed or timed out');
            }
            
            return file.uri;
        }
        
        // Check if manual cache needs refresh (7 days)
        function needsCacheRefresh(lastUpdated) {
            if (!lastUpdated) return true;
            
            const lastUpdate = new Date(lastUpdated);
            const now = new Date();
            const daysSinceUpdate = (now - lastUpdate) / (1000 * 60 * 60 * 24);
            
            return daysSinceUpdate >= 7;
        }
        
        // Refresh manual from Google Drive and upload to Gemini
        async function refreshManualCache(key, manualId, showProgress = true) {
            const manuals = manualMappings[key];
            if (!manuals || !Array.isArray(manuals)) {
                throw new Error('No manuals found for this equipment');
            }
            
            const manual = manuals.find(m => m.id === manualId);
            if (!manual || !manual.url) {
                throw new Error('No manual URL found');
            }
            
            if (showProgress) {
                showSyncStatus('syncing', `üì• Downloading "${manual.name}" from Google Drive...`);
            }
            
            try {
                // Download PDF from Google Drive
                const pdfBlob = await downloadPDFFromGoogleDrive(manual.url);
                
                if (showProgress) {
                    showSyncStatus('syncing', `‚òÅÔ∏è Uploading "${manual.name}" to Gemini...`);
                }
                
                // Upload to Gemini File API
                const geminiFileUri = await uploadPDFToGemini(pdfBlob, manual.name);
                
                // Update cache in the specific manual object
                manual.geminiFileUri = geminiFileUri;
                manual.lastUpdated = new Date().toISOString();
                
                // Save to localStorage
                localStorage.setItem('manualMappings', JSON.stringify(manualMappings));
                
                // Sync to cloud
                await syncAIConfigsToCloud();
                
                if (showProgress) {
                    showSyncStatus('success', `‚úì "${manual.name}" cached successfully!`);
                }
                
                return geminiFileUri;
            } catch (error) {
                console.error('Error refreshing manual cache:', error);
                if (showProgress) {
                    showSyncStatus('error', '‚úó Failed to cache manual: ' + error.message);
                }
                throw error;
            }
        }
        
        // Get manual file URIs for all manuals of this equipment (with auto-refresh if needed)
        async function getManualFileUris(key, showProgress = true) {
            const manuals = manualMappings[key];
            if (!manuals || !Array.isArray(manuals) || manuals.length === 0) {
                return []; // No manuals mapped
            }
            
            const fileUris = [];
            
            for (const manual of manuals) {
                try {
                    // Check if we have a cached file URI and if it needs refresh
                    if (manual.geminiFileUri && !needsCacheRefresh(manual.lastUpdated)) {
                        fileUris.push({
                            uri: manual.geminiFileUri,
                            name: manual.name
                        });
                    } else {
                        // Need to refresh this manual
                        const uri = await refreshManualCache(key, manual.id, showProgress);
                        fileUris.push({
                            uri: uri,
                            name: manual.name
                        });
                    }
                } catch (error) {
                    console.error(`Error loading manual "${manual.name}":`, error);
                    // Continue with other manuals even if one fails
                }
            }
            
            return fileUris;
        }

        async function saveManualMapping() {
            const line = document.getElementById('manual-line').value.trim();
            const machine = document.getElementById('manual-machine').value.trim();
            const manualName = document.getElementById('manual-name').value.trim();
            const url = document.getElementById('manual-url').value.trim();
            
            // Validate inputs
            if (!line) {
                alert('Please select a production line');
                return;
            }
            if (!machine) {
                alert('Please enter equipment name');
                return;
            }
            if (!manualName) {
                alert('Please enter manual name');
                return;
            }
            if (!url) {
                alert('Please enter manual URL');
                return;
            }
            
            // Create key in format "LINE-MACHINE"
            const key = `${line}-${machine}`;
            
            // Initialize array if doesn't exist
            if (!manualMappings[key]) {
                manualMappings[key] = [];
            }
            
            // Check if this exact manual URL already exists
            const existingManual = manualMappings[key].find(m => m.url === url);
            if (existingManual) {
                alert(`This manual URL is already added for ${line} - ${machine}.`);
                return;
            }
            
            // Add manual to array with unique ID
            const manualId = Date.now().toString();
            manualMappings[key].push({
                id: manualId,
                name: manualName,
                url: url
            });
            
            // Save to localStorage
            localStorage.setItem('manualMappings', JSON.stringify(manualMappings));
            
            // Close modal
            closeManualModal();
            
            // Update display
            renderManualMappings();
            
            // Sync to cloud with better feedback
            showSyncStatus('syncing', '‚òÅÔ∏è Syncing manual mapping to Google Sheets...');
            
            try {
                const success = await syncAIConfigsToCloud();
                if (success) {
                    showSyncStatus('success', `‚úì Manual mapping for ${line} - ${machine} saved and synced to cloud!`);
                } else {
                    showSyncStatus('error', '‚úó Cloud sync may have failed - manual saved locally. Check Google Sheet to verify.');
                }
            } catch (error) {
                console.error('Sync error:', error);
                showSyncStatus('error', '‚úó Cloud sync failed - manual saved locally only');
            }
        }

        function removeManualMapping(key, manualId) {
            // Extract line and machine from key for display
            const [line, machine] = key.split('-', 2);
            
            // Get the manual to display its name
            const manuals = manualMappings[key];
            if (!manuals || !Array.isArray(manuals)) {
                alert('Error: Manual not found');
                return;
            }
            
            const manual = manuals.find(m => m.id === manualId);
            if (!manual) {
                alert('Error: Manual not found');
                return;
            }
            
            if (confirm(`Remove "${manual.name}" from ${line} - ${machine}?`)) {
                // Remove this specific manual from the array
                manualMappings[key] = manuals.filter(m => m.id !== manualId);
                
                // If no manuals left, remove the key entirely
                if (manualMappings[key].length === 0) {
                    delete manualMappings[key];
                }
                
                localStorage.setItem('manualMappings', JSON.stringify(manualMappings));
                renderManualMappings();
                syncAIConfigsToCloud();
                alert(`‚úì Manual "${manual.name}" removed and synced to cloud!`);
            }
        }

        async function refreshSingleManual(key, manualId) {
            const [line, machine] = key.split('-', 2);
            
            const manuals = manualMappings[key];
            if (!manuals || !Array.isArray(manuals)) {
                alert('Error: Manual not found');
                return;
            }
            
            const manual = manuals.find(m => m.id === manualId);
            if (!manual) {
                alert('Error: Manual not found');
                return;
            }
            
            if (!confirm(`Refresh "${manual.name}" for ${line} - ${machine}?\n\nThis will download the latest version from Google Drive.`)) {
                return;
            }
            
            try {
                await refreshManualCache(key, manualId, true);
                renderManualMappings();
                alert(`‚úì "${manual.name}" refreshed successfully!`);
            } catch (error) {
                alert(`‚úó Failed to refresh PDF: ${error.message}`);
            }
        }

        // ====== PDF DOWNLOAD TESTING ======
        function openTestPDFModal() {
            document.getElementById('test-pdf-modal').style.display = 'flex';
            document.getElementById('test-pdf-result').innerHTML = '';
            
            // Pre-fill with first manual's URL if available
            const firstManual = Object.values(manualMappings)[0];
            if (firstManual && firstManual.url) {
                document.getElementById('test-pdf-url').value = firstManual.url;
            }
        }

        function closeTestPDFModal() {
            document.getElementById('test-pdf-modal').style.display = 'none';
        }

        function handleTestPDFModalClick(event) {
            if (event.target.id === 'test-pdf-modal') {
                closeTestPDFModal();
            }
        }

        async function testPDFDownload() {
            const url = document.getElementById('test-pdf-url').value.trim();
            const resultDiv = document.getElementById('test-pdf-result');
            
            if (!url) {
                resultDiv.innerHTML = '<div style="color: #dc3545;">Please enter a Google Drive URL</div>';
                return;
            }
            
            if (!GOOGLE_SCRIPT_URL) {
                resultDiv.innerHTML = '<div style="color: #dc3545;">‚ùå Google Apps Script URL not configured. Please set it in the Setup tab.</div>';
                return;
            }
            
            resultDiv.innerHTML = '<div style="color: #666;">üîÑ Testing PDF download...</div>';
            
            try {
                // Test the download
                const blob = await downloadPDFFromGoogleDrive(url);
                
                resultDiv.innerHTML = `
                    <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; padding: 15px; color: #155724;">
                        <strong>‚úì Success!</strong><br>
                        <span style="font-size: 14px;">
                            PDF downloaded successfully from Google Drive via Google Apps Script proxy.<br>
                            Size: ${(blob.size / 1024).toFixed(2)} KB<br>
                            Type: ${blob.type}
                        </span>
                    </div>
                `;
            } catch (error) {
                console.error('Test error:', error);
                resultDiv.innerHTML = `
                    <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; padding: 15px; color: #721c24;">
                        <strong>‚ùå Failed</strong><br>
                        <span style="font-size: 14px;">${error.message}</span>
                        <div style="margin-top: 10px; font-size: 13px;">
                            <strong>Common Issues:</strong><br>
                            ‚Ä¢ Google Apps Script not deployed with v13 code<br>
                            ‚Ä¢ Google Script URL not configured<br>
                            ‚Ä¢ File not publicly accessible<br>
                            ‚Ä¢ Invalid file ID in URL
                        </div>
                    </div>
                `;
            }
        }

        // ====== TAB SECURITY ======
        
        // ‚öôÔ∏è CONFIGURATION: Change PIN here and deploy via GitHub
        // Default PIN: 1111
        // To change: Edit this value, commit to GitHub, deploy to all devices
        const SECURITY_PIN = "1111";
        const SECURITY_ENABLED = true; // Set to false to disable tab protection
        
        // Session authentication - cleared when browser closes
        let isAuthenticated = sessionStorage.getItem('tabSecurityAuth') === 'true';

        // Security modal handling
        function handleSecurityModalClick(event) {
            if (event.target.id === 'security-modal') {
                closeSecurityModal();
            }
        }

        function closeSecurityModal() {
            document.getElementById('security-modal').style.display = 'none';
            // Return to previous tab or default tab
            const currentTab = document.querySelector('.tab-content.active');
            if (currentTab && (currentTab.id === 'settings-tab' || currentTab.id === 'definitions-tab')) {
                switchTab('report'); // Go back to report tab
            }
        }

        function checkSecurityPIN() {
            const enteredPIN = document.getElementById('security-pin-entry').value.trim();
            const errorDiv = document.getElementById('security-error');
            
            if (enteredPIN === SECURITY_PIN) {
                // Correct PIN
                sessionStorage.setItem('tabSecurityAuth', 'true');
                isAuthenticated = true;
                document.getElementById('security-modal').style.display = 'none';
                
                // Now actually switch to the requested tab
                const requestedTab = sessionStorage.getItem('requestedSecureTab');
                if (requestedTab) {
                    sessionStorage.removeItem('requestedSecureTab');
                    // Actually switch to the tab
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.querySelectorAll('.tab-button').forEach(button => {
                        button.classList.remove('active');
                    });
                    
                    document.getElementById(requestedTab).classList.add('active');
                    document.querySelector(`[onclick="switchTab('${requestedTab.replace('-tab', '')}')"]`).classList.add('active');
                }
            } else {
                // Incorrect PIN
                errorDiv.style.display = 'block';
                document.getElementById('security-pin-entry').value = '';
                document.getElementById('security-pin-entry').focus();
                
                // Shake animation
                const modal = document.querySelector('#security-modal .modal-content');
                modal.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    modal.style.animation = '';
                }, 500);
            }
        }

        // ====== DEFINITIONS MANAGEMENT ======
        function initializeDefaultDefinitions() {
            // Only initialize if no definitions exist
            if (definitions.length > 0) return;
            
            const defaultDefinitions = [
                // Terminology
                { id: 'def-1', category: 'Terminology', term: 'Substrate / Applicator', definition: 'The raw material (dry fabric/paper) that becomes wipes. Pre-slit rolls arrive at correct width for most lines.', equipment: 'All' },
                { id: 'def-2', category: 'Terminology', term: 'Solution', definition: 'The liquid (lotion) applied to substrate at the wetting tube to create wet wipes.', equipment: 'Forming' },
                { id: 'def-3', category: 'Terminology', term: 'Log / Ribbon', definition: 'Continuous stream of interleaved sheets before cutting. Created by forming boards layering sheets from multiple rolls.', equipment: 'Forming' },
                { id: 'def-4', category: 'Terminology', term: 'Clip', definition: 'A cut section of the log with specific count (e.g., 50 wipes, 80 wipes). Cut by saw house/clipper.', equipment: 'Saw House' },
                { id: 'def-5', category: 'Terminology', term: 'Stack', definition: 'Final unit ready for wrapping. May be single clip or multiple clips stacked together to reach target count (e.g., two 50-count clips = one 100-count stack).', equipment: 'Stacker' },
                { id: 'def-6', category: 'Terminology', term: 'Interleaf / Interleaving', definition: 'Layering sheets from multiple substrate rolls in alternating pattern so each wipe pulls the next one up when dispensed.', equipment: 'Forming' },
                { id: 'def-7', category: 'Terminology', term: 'Film', definition: 'Plastic wrapping material used at wrapper stage to seal the wipe packages.', equipment: 'Wrapper' },
                { id: 'def-8', category: 'Terminology', term: 'Pre-slit vs Jumbo Rolls', definition: 'Pre-slit: Rolls already cut to correct width (JBFlex, HH, RX300, L80). Jumbo: Full-width rolls requiring on-machine slitting (RX500 only).', equipment: 'Unwind' },
                
                // Equipment
                { id: 'def-9', category: 'Equipment', term: 'Unwind', definition: 'Holds and feeds substrate rolls at the start of the line. RX500 has slitting units; other lines use pre-slit rolls.', equipment: 'Unwind' },
                { id: 'def-10', category: 'Equipment', term: 'Wetting Tube', definition: 'Applies solution (lotion) to substrate as it travels across to create wet wipes.', equipment: 'Forming' },
                { id: 'def-11', category: 'Equipment', term: 'Forming Boards', definition: 'Folds individual sheets and interleafs them to create the continuous log/ribbon.', equipment: 'Forming' },
                { id: 'def-12', category: 'Equipment', term: 'Saw House / Clipper', definition: 'Cuts the continuous log into clips of specific lengths/counts.', equipment: 'Saw House' },
                { id: 'def-13', category: 'Equipment', term: 'Stacker', definition: 'Stacks multiple clips together when needed to reach final product count (e.g., stacking two 50-count clips for 100-count product).', equipment: 'Stacker' },
                { id: 'def-14', category: 'Equipment', term: 'Wrapper', definition: 'Wraps product in plastic film and applies lid to create final packaged wipe container.', equipment: 'Wrapper' },
                { id: 'def-15', category: 'Equipment', term: 'Case Erector', definition: 'Creates cardboard shipping cases for packaging.', equipment: 'Case Packer' },
                { id: 'def-16', category: 'Equipment', term: 'Case Packer', definition: 'Uses robots to place wrapped products into shipping cases.', equipment: 'Case Packer' },
                { id: 'def-17', category: 'Equipment', term: 'Palletizer', definition: 'Stacks completed cases onto pallets for shipping. Includes stretch wrapping.', equipment: 'Palletizer' },
                
                // Common Issues
                { id: 'def-18', category: 'Issue', term: 'Web Walk', definition: 'LOCATION-SPECIFIC ISSUE:\n‚Ä¢ At Clipper/Forming/Unwind: Substrate/applicator moving off forming boards or drifting left/right on rollers instead of tracking straight.\n‚Ä¢ At Wrapper: Plastic film coming out crooked or off-center from forming box.\nCauses misalignment, jams, and quality issues.', equipment: 'Wrapper, Forming, Unwind' },
                { id: 'def-19', category: 'Issue', term: 'Sheet Peel / Peel', definition: 'Bottom sheet of clip or stack pulling back or falling loose from the unit. Typically occurs between stacker and wrapper. Causes wrapper sealing failures as film cannot seal properly when bottom sheet is loose. Often results in product rejects.', equipment: 'Stacker, Wrapper' },
                { id: 'def-20', category: 'Issue', term: 'Slits in Packs', definition: 'Cuts, tears, or breaks in the plastic film wrapper. Product defect that compromises package integrity, may cause leaking or drying out. When reported "at the wrapper," refers specifically to film damage, not substrate issues.', equipment: 'Wrapper' },
                
                // Process
                { id: 'def-21', category: 'Process', term: 'Forming Process', definition: 'Substrate travels across wetting tube (solution applied), then across forming boards which fold and interleaf sheets from multiple rolls to create the continuous log/ribbon.', equipment: 'Forming' },
                { id: 'def-22', category: 'Process', term: 'Slitting', definition: 'Cutting substrate to required width. RX500 has on-machine slitting units for jumbo rolls. Other lines (JBFlex, HH, RX300, L80) use pre-slit rolls.', equipment: 'Unwind' },
                { id: 'def-23', category: 'Process', term: 'Stacking', definition: 'Combining multiple clips to reach final product count. Example: two 50-count clips stacked to make 100-count product. Some products skip this step (single clip = final stack).', equipment: 'Stacker' }
            ];
            
            definitions = defaultDefinitions;
            localStorage.setItem('definitions', JSON.stringify(definitions));
            syncDefinitionsToCloud();
        }

        function renderDefinitions() {
            const container = document.getElementById('definitions-list');
            if (!container) return;
            
            const searchTerm = (document.getElementById('definitions-search')?.value || '').toLowerCase();
            
            // Filter definitions
            let filtered = definitions;
            if (searchTerm) {
                filtered = definitions.filter(def => 
                    def.term.toLowerCase().includes(searchTerm) ||
                    def.definition.toLowerCase().includes(searchTerm) ||
                    (def.equipment && def.equipment.toLowerCase().includes(searchTerm))
                );
            }
            
            if (filtered.length === 0) {
                container.innerHTML = '<div class="no-definitions">No definitions found. Click "Add Definition" to create one.</div>';
                return;
            }
            
            // Group by category
            const categories = {
                'Terminology': { emoji: 'üè∑Ô∏è', items: [] },
                'Equipment': { emoji: '‚öôÔ∏è', items: [] },
                'Issue': { emoji: '‚ö†Ô∏è', items: [] },
                'Process': { emoji: 'üîÑ', items: [] }
            };
            
            filtered.forEach(def => {
                if (categories[def.category]) {
                    categories[def.category].items.push(def);
                }
            });
            
            let html = '';
            
            for (const [catName, catData] of Object.entries(categories)) {
                if (catData.items.length === 0) continue;
                
                html += `
                    <div class="definition-category">
                        <div class="definition-category-header">
                            <span>${catData.emoji} ${catName.toUpperCase()} (${catData.items.length})</span>
                        </div>
                `;
                
                catData.items.forEach(def => {
                    html += `
                        <div class="definition-item">
                            <div class="definition-term">${def.term}</div>
                            <div class="definition-text">${def.definition.replace(/\n/g, '<br>')}</div>
                            <div class="definition-meta">
                                <div class="definition-equipment">
                                    ${def.equipment ? `üìç ${def.equipment}` : ''}
                                </div>
                                <div class="definition-actions">
                                    <button class="btn btn-info" onclick="editDefinition('${def.id}')">Edit</button>
                                    <button class="btn" onclick="deleteDefinition('${def.id}')" style="background: #dc3545; color: white;">Delete</button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            container.innerHTML = html;
        }

        function filterDefinitions() {
            renderDefinitions();
        }

        function openDefinitionModal(defId = null) {
            const modal = document.getElementById('definition-modal');
            const title = document.getElementById('definition-modal-title');
            
            if (defId) {
                // Edit mode
                const def = definitions.find(d => d.id === defId);
                if (!def) return;
                
                title.textContent = 'Edit Definition';
                document.getElementById('definition-category').value = def.category;
                document.getElementById('definition-term').value = def.term;
                document.getElementById('definition-text').value = def.definition;
                document.getElementById('definition-equipment').value = def.equipment || '';
                currentEditingDefinitionId = defId;
            } else {
                // Add mode
                title.textContent = 'Add Definition';
                document.getElementById('definition-category').value = '';
                document.getElementById('definition-term').value = '';
                document.getElementById('definition-text').value = '';
                document.getElementById('definition-equipment').value = '';
                currentEditingDefinitionId = null;
            }
            
            modal.style.display = 'block';
        }

        function closeDefinitionModal() {
            document.getElementById('definition-modal').style.display = 'none';
            currentEditingDefinitionId = null;
        }

        function handleDefinitionModalClick(event) {
            if (event.target.id === 'definition-modal') {
                closeDefinitionModal();
            }
        }

        async function saveDefinition() {
            const category = document.getElementById('definition-category').value.trim();
            const term = document.getElementById('definition-term').value.trim();
            const definition = document.getElementById('definition-text').value.trim();
            const equipment = document.getElementById('definition-equipment').value.trim();
            
            if (!category) {
                alert('Please select a category');
                return;
            }
            if (!term) {
                alert('Please enter a term/name');
                return;
            }
            if (!definition) {
                alert('Please enter a definition');
                return;
            }
            
            if (currentEditingDefinitionId) {
                // Edit existing
                const index = definitions.findIndex(d => d.id === currentEditingDefinitionId);
                if (index !== -1) {
                    definitions[index] = {
                        id: currentEditingDefinitionId,
                        category,
                        term,
                        definition,
                        equipment
                    };
                }
            } else {
                // Add new
                const newDef = {
                    id: 'def-' + Date.now(),
                    category,
                    term,
                    definition,
                    equipment
                };
                definitions.push(newDef);
            }
            
            localStorage.setItem('definitions', JSON.stringify(definitions));
            closeDefinitionModal();
            renderDefinitions();
            
            // Sync to cloud
            showSyncStatus('syncing', '‚òÅÔ∏è Syncing definitions to Google Sheets...');
            try {
                await syncDefinitionsToCloud();
                showSyncStatus('success', `‚úì Definition "${term}" saved and synced!`);
            } catch (error) {
                console.error('Sync error:', error);
                showSyncStatus('error', '‚úó Cloud sync failed - definition saved locally only');
            }
        }

        function editDefinition(defId) {
            openDefinitionModal(defId);
        }

        async function deleteDefinition(defId) {
            const def = definitions.find(d => d.id === defId);
            if (!def) return;
            
            if (!confirm(`Delete definition for "${def.term}"?`)) {
                return;
            }
            
            definitions = definitions.filter(d => d.id !== defId);
            localStorage.setItem('definitions', JSON.stringify(definitions));
            renderDefinitions();
            
            await syncDefinitionsToCloud();
            showSyncStatus('success', '‚úì Definition deleted and synced!');
        }

        async function syncDefinitionsToCloud() {
            return new Promise((resolve) => {
                try {
                    let iframe = document.getElementById('sync-iframe');
                    if (!iframe) {
                        iframe = document.createElement('iframe');
                        iframe.id = 'sync-iframe';
                        iframe.name = 'sync-iframe';
                        iframe.style.display = 'none';
                        document.body.appendChild(iframe);
                    }
                    
                    let form = document.getElementById('definitions-sync-form');
                    if (form) form.remove();
                    
                    form = document.createElement('form');
                    form.id = 'definitions-sync-form';
                    form.method = 'POST';
                    form.action = GOOGLE_SCRIPT_URL;
                    form.target = 'sync-iframe';
                    form.style.display = 'none';
                    
                    const actionInput = document.createElement('input');
                    actionInput.type = 'hidden';
                    actionInput.name = 'action';
                    actionInput.value = 'saveDefinitions';
                    form.appendChild(actionInput);
                    
                    const definitionsInput = document.createElement('input');
                    definitionsInput.type = 'hidden';
                    definitionsInput.name = 'definitions';
                    definitionsInput.value = JSON.stringify(definitions);
                    form.appendChild(definitionsInput);
                    
                    document.body.appendChild(form);
                    form.submit();
                    
                    setTimeout(() => {
                        resolve(true);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Definitions sync error:', error);
                    resolve(false);
                }
            });
        }

        function getDefinitionsContext() {
            if (definitions.length === 0) return '';
            
            let context = '\n\n=== MANUFACTURING FACILITY CONTEXT ===\n';
            context += 'Facility: Baby Wipes Production\n';
            context += 'Lines: JBFlex, HH, RX500, RX300, L80\n\n';
            
            const categories = {
                'Terminology': [],
                'Equipment': [],
                'Issue': [],
                'Process': []
            };
            
            definitions.forEach(def => {
                if (categories[def.category]) {
                    categories[def.category].push(def);
                }
            });
            
            for (const [catName, items] of Object.entries(categories)) {
                if (items.length === 0) continue;
                
                context += `${catName.toUpperCase()}:\n`;
                items.forEach(def => {
                    context += `‚Ä¢ ${def.term}: ${def.definition}`;
                    if (def.equipment) {
                        context += ` [Applies to: ${def.equipment}]`;
                    }
                    context += '\n';
                });
                context += '\n';
            }
            
            return context;
        }

        // ====== AI WORK INSTRUCTION ======
        async function generateWorkInstruction() {
            const line = document.getElementById('ai-line').value;
            const machine = document.getElementById('ai-machine').value;
            const issue = document.getElementById('ai-issue').value;
            
            if (!line || !machine || !issue) {
                alert('Please fill in all required fields');
                return;
            }

            // Check configuration based on selected provider
            if (selectedProvider === 'gemini') {
                if (!geminiConfig.apiKey) {
                    showConfigurationRequired('Google Gemini', 'Get your free API key at ai.google.dev');
                    return;
                }
            } else if (selectedProvider === 'azure') {
                if (!azureConfig.endpoint || !azureConfig.apiKey) {
                    showConfigurationRequired('Azure OpenAI', 'Configure your Azure OpenAI credentials');
                    return;
                }
            }

            // Show loading state
            document.getElementById('generated-instruction').innerHTML = `
                <div class="work-instruction">
                    <div class="wi-header">ü§ñ GENERATING AI WORK INSTRUCTION</div>
                    <div style="padding: 60px 20px; text-align: center; background: white;">
                        <div class="loading-spinner"></div>
                        <p style="margin-top: 25px; color: #666; font-size: 15px;">
                            <strong>Retrieving information from equipment manuals and definitions...</strong><br>
                            <span style="font-size: 14px;">Consulting ${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'} AI...</span>
                        </p>
                    </div>
                </div>
            `;

            try {
                // Get manual info and file URIs using LINE-MACHINE key
                const manualKey = `${line}-${machine}`;
                const manualsArray = manualMappings[manualKey];
                let manualContext = '';
                let geminiFileUris = [];
                
                // Handle both old single-object format and new array format for migration
                const manuals = manualsArray && Array.isArray(manualsArray) ? manualsArray : 
                               (manualsArray ? [manualsArray] : []);
                
                if (manuals.length > 0) {
                    manualContext = '\n\nEquipment Manual References:\n';
                    manuals.forEach((manual, index) => {
                        manualContext += `${index + 1}. ${manual.name}\n   URL: ${manual.url}\n`;
                    });
                    
                    // Try to get Gemini file URIs (with auto-refresh if needed)
                    if (selectedProvider === 'gemini') {
                        try {
                            // Update loading message
                            document.getElementById('generated-instruction').innerHTML = `
                                <div class="work-instruction">
                                    <div class="wi-header">ü§ñ GENERATING AI WORK INSTRUCTION</div>
                                    <div style="padding: 60px 20px; text-align: center; background: white;">
                                        <div class="loading-spinner"></div>
                                        <p style="margin-top: 25px; color: #666; font-size: 15px;">
                                            <strong>Fetching ${manuals.length} equipment manual${manuals.length !== 1 ? 's' : ''} from Google Drive...</strong><br>
                                            <span style="font-size: 14px;">This may take a moment if manuals need updating...</span>
                                        </p>
                                    </div>
                                </div>
                            `;
                            
                            geminiFileUris = await getManualFileUris(manualKey, false);
                            
                            if (geminiFileUris.length > 0) {
                                manualContext += `\n(${geminiFileUris.length} PDF manual${geminiFileUris.length !== 1 ? 's' : ''} included and accessible to AI)`;
                            } else {
                                // PDFs were not available - should not happen if getManualFileUris succeeds
                                throw new Error('Failed to obtain PDF file references');
                            }
                        } catch (error) {
                            console.error('Error fetching manuals:', error);
                            
                            // CRITICAL: If manuals are mapped but we can't get the PDFs, don't generate
                            const manualsList = manuals.map(m => `‚Ä¢ ${m.name}`).join('\n');
                            document.getElementById('generated-instruction').innerHTML = `
                                <div class="work-instruction">
                                    <div class="wi-header" style="background: linear-gradient(135deg, #dc3545, #c82333);">‚ùå MANUAL ACCESS FAILED</div>
                                    <div style="padding: 40px 25px; background: white;">
                                        <div style="font-size: 48px; margin-bottom: 20px; text-align: center;">üìÑ</div>
                                        <h3 style="color: #dc3545; margin-bottom: 15px;">Cannot Access Equipment Manuals</h3>
                                        <p style="color: #666; margin-bottom: 20px;">
                                            ${manuals.length} manual${manuals.length !== 1 ? 's are' : ' is'} configured for ${line} - ${machine}, but ${manuals.length !== 1 ? 'they' : 'it'} could not be downloaded from Google Drive.
                                        </p>
                                        <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 15px; margin-bottom: 20px;">
                                            <strong style="color: #856404;">Error:</strong><br>
                                            <span style="color: #856404; font-size: 14px;">${error.message}</span>
                                        </div>
                                        <h4 style="margin-top: 20px; margin-bottom: 10px;">Configured Manuals:</h4>
                                        <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; text-align: left;">${manualsList}</pre>
                                        <h4 style="margin-top: 20px; margin-bottom: 10px;">Troubleshooting Steps:</h4>
                                        <ol style="text-align: left; color: #666; line-height: 1.8;">
                                            <li><strong>Check Google Drive Links:</strong> Verify all files are publicly accessible (Anyone with link can view)</li>
                                            <li><strong>Check Google Apps Script:</strong> Ensure you've deployed v13 with PDF download proxy</li>
                                            <li><strong>Check Script URL:</strong> Verify Google Apps Script URL is configured in Setup tab</li>
                                            <li><strong>Test Manually:</strong> Try clicking the üîÑ Refresh button on each manual in Setup tab</li>
                                        </ol>
                                        <div style="text-align: center; margin-top: 30px;">
                                            <button onclick="switchTab('settings')" class="btn btn-primary">
                                                Go to Setup
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            `;
                            return; // Stop - don't generate without the manuals
                        }
                    }
                }

                // Update loading message for AI generation
                const manualCount = geminiFileUris.length;
                document.getElementById('generated-instruction').innerHTML = `
                    <div class="work-instruction">
                        <div class="wi-header">ü§ñ GENERATING AI WORK INSTRUCTION</div>
                        <div style="padding: 60px 20px; text-align: center; background: white;">
                            <div class="loading-spinner"></div>
                            <p style="margin-top: 25px; color: #666; font-size: 15px;">
                                <strong>Generating instructions from ${manualCount > 0 ? manualCount + ' equipment manual' + (manualCount !== 1 ? 's' : '') : 'available information'}...</strong><br>
                                <span style="font-size: 14px;">Consulting ${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'} AI...</span>
                            </p>
                        </div>
                    </div>
                `;

                // Get definitions context
                const definitionsContext = getDefinitionsContext();
                
                const hasManuals = geminiFileUris.length > 0;
                const manualNames = geminiFileUris.map(m => m.name).join(', ');

                // Create the prompt
                const prompt = `You are a technical documentation assistant. Your job is to help users find and extract procedures from equipment manuals.

${definitionsContext}
EQUIPMENT INFORMATION:
- Production Line: ${line}
- Machine/Equipment: ${machine}
- User Request: ${issue}
${manualContext}

YOUR TWO-STEP PROCESS:

STEP 1 - UNDERSTAND THE REQUEST (Be Smart & Flexible):
${hasManuals ? `
- The user may not use exact manual terminology
- They might ask: "fix the conveyor" when they mean "adjust clip conveyor height"
- They might say: "change the blade" when they mean "replace cutting blade assembly"
- Use your intelligence to interpret what procedure they're most likely asking for
- Search across ALL ${geminiFileUris.length} manual${geminiFileUris.length !== 1 ? 's' : ''} for the procedure that best matches their intent
- Consider common variations and related procedures
- If information spans multiple manuals, synthesize it coherently
` : `
- Understand what the user is asking for
- No manual available - explain that specific procedure cannot be provided
`}

STEP 2 - EXTRACT THE PROCEDURE (Be Strict & Accurate):
${hasManuals ? `
Once you've found the right procedure in the manual(s):
- Extract ONLY what is explicitly written in the manuals
- Do NOT add steps that aren't there
- Do NOT elaborate on brief instructions
- Do NOT add tool specifications if not listed
- Do NOT add measurements if not specified
- Keep it as brief or detailed as the manual states it
- Cite everything with manual name: [Source: Manual Name, Page X]
- When information comes from multiple manuals, cite each source

CRITICAL - VISUAL CONTENT USAGE:
The manual PDFs include images, diagrams, photos, and illustrations. You MUST actively reference these:
- When diagrams exist, reference them: "See Figure 3 for belt alignment" or "Refer to diagram on Page 12"
- Describe visual indicators: "The red safety lever shown in the photo..." or "Note the arrow indicating direction in the diagram"
- Call out important visual cues: "The wiring diagram on page X shows correct connections"
- Reference part locations from images: "Component is located as shown in Figure 2"
- Note color-coded parts: "Connect to the blue terminal (shown in diagram)"
- Mention callouts/labels: "Part #5 in the exploded view diagram"
- When images clarify steps: "Assembly orientation is shown in the illustration"
- If images are critical: "IMPORTANT: Study the photo on page X before proceeding"
- When info spans manuals: "Refer to ${manualNames} for complete visual references"

Even if the text is brief, ALWAYS check for and reference relevant diagrams, photos, or illustrations that support the procedure.

If the procedure is NOT in any of the manuals:
- State clearly: "This procedure is not documented in the available manuals"
- Do NOT make up a procedure from general knowledge
- Suggest consulting supervisor or manufacturer
` : `
- Manual not available
- Cannot provide specific procedure
- Direct user to consult equipment manual and supervisor
`}

RESPONSE FORMAT:

WORK INSTRUCTION - ${machine.toUpperCase()}

SAFETY PRECAUTIONS:
All company policies and LOTO (Lockout/Tagout) procedures must be followed at all times.
${hasManuals ? '[Extract ONLY the safety warnings explicitly stated in the manuals for this procedure. Reference any safety diagrams or warning symbols shown in images. Cite which manual each warning comes from.]' : '[Consult equipment manual for specific safety procedures]'}

REQUIRED TOOLS & MATERIALS:
${hasManuals ? '[List ONLY tools explicitly mentioned in the manuals - if none listed, state "Tools not specified in manuals". If tools are shown in images/photos, reference them. Cite source manual.]' : '[Consult manual for required tools]'}

VISUAL REFERENCES:
${hasManuals ? '[List all relevant diagrams, figures, photos, or illustrations by page number that relate to this procedure. Example: "Figure 5 (Page 23, Stacker Manual) - Belt tension adjustment points" or "Photo on Page 15 (HMI Manual) - Correct wrench positioning"]' : '[Not available]'}

PROCEDURE STEPS:
${hasManuals ? '[Extract steps EXACTLY as written in the manuals. For EACH step where a diagram/image exists, add the reference. Example: "1. Remove cover plate (see Figure 3 on Page 12 of Stacker Manual)" or "2. Align shaft as shown in diagram". If procedure spans multiple manuals, integrate them logically and cite each source.]' : '[Procedure not available - consult equipment manual]'}

VERIFICATION:
${hasManuals ? '[Include ONLY verification steps explicitly stated in the manuals. Reference any inspection photos or measurement diagrams if shown. Cite source manual.]' : '[Consult manual for verification procedures]'}

IMPORTANT NOTES:
${hasManuals ? `- All information extracted directly from ${geminiFileUris.length} manual${geminiFileUris.length !== 1 ? 's' : ''} without additions: ${manualNames}
- Brief instructions kept brief, detailed instructions kept detailed
- Missing details noted as "See [Manual Name] for specifications"
- Diagrams and images actively referenced throughout to aid understanding
- Information from multiple manuals integrated where relevant
- User must verify against original manuals and images before implementing` : '- Consult equipment manual and supervisor for specific procedures'}
${hasManuals ? '\n- Equipment Manuals: ' + manualNames : ''}

CRITICAL REMINDER: 
Be SMART in finding the right procedure (the user may not use exact terms). Search ALL available manuals.
Be STRICT in extracting it (only what's actually written, nothing more).
ACTIVELY REFERENCE visual content (diagrams, photos, figures) throughout your response.
CITE which manual each piece of information comes from when you have multiple manuals.`;

                // Call the appropriate AI service
                let response;
                if (selectedProvider === 'gemini') {
                    response = await callGeminiAPI(prompt, geminiFileUris);
                } else {
                    response = await callAzureOpenAI(prompt);
                }
                
                // Display the result
                displayWorkInstruction(response, line, machine, issue);

            } catch (error) {
                console.error('Error generating work instruction:', error);
                document.getElementById('generated-instruction').innerHTML = `
                    <div class="work-instruction">
                        <div class="wi-header" style="background: linear-gradient(135deg, #dc3545, #c82333);">‚ùå ERROR</div>
                        <div style="padding: 40px 25px; text-align: center; background: white;">
                            <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                            <h3 style="color: #dc3545; margin-bottom: 15px;">Failed to Generate Work Instruction</h3>
                            <p style="color: #666; margin-bottom: 20px; font-size: 15px;">${error.message}</p>
                            <p style="color: #666; font-size: 14px;">
                                Please check your ${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'} configuration in the Setup tab.
                            </p>
                            <button onclick="switchTab('settings')" class="btn btn-primary" style="margin-top: 20px;">
                                Go to Setup
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        function showConfigurationRequired(providerName, message) {
            const html = `
                <div class="work-instruction">
                    <div class="wi-header" style="background: linear-gradient(135deg, #ffc107, #ff9800);">‚öôÔ∏è CONFIGURATION REQUIRED</div>
                    <div style="padding: 60px 25px; text-align: center; background: white;">
                        <div style="font-size: 64px; margin-bottom: 20px;">üîß</div>
                        <h3 style="color: #ff9800; margin-bottom: 15px;">${providerName} Not Configured</h3>
                        <p style="color: #666; margin: 20px auto; max-width: 500px; font-size: 15px;">
                            ${message}
                        </p>
                        <button onclick="switchTab('settings')" class="btn btn-primary" style="margin-top: 20px; padding: 15px 30px; font-size: 16px;">
                            Go to Setup Tab
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('generated-instruction').innerHTML = html;
        }

        function displayWorkInstruction(content, line, machine, issue) {
            // Helper function to clean up markdown formatting
            function cleanMarkdown(text) {
                // Remove leading asterisks and bullet points
                text = text.replace(/^\*\*(.+?)\*\*$/gm, '$1'); // Remove bold markers on whole lines
                text = text.replace(/^\*\s+/gm, ''); // Remove bullet points
                text = text.replace(/^[\*‚Ä¢]\s*/gm, ''); // Remove asterisk or bullet bullets
                
                // Clean up inline formatting but keep citations
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>'); // Bold
                text = text.replace(/\[Source:/g, '<span class="citation">[Source:'); // Start citation
                text = text.replace(/\]/g, ']</span>'); // End citation (will catch citations)
                
                return text.trim();
            }
            
            // Helper function to identify and format different line types
            function formatLine(line) {
                line = line.trim();
                if (!line) return '';
                
                // Check if it's a numbered step (e.g., "1.", "2.", etc.)
                const numberedMatch = line.match(/^(\d+)\.\s*(.+)$/);
                if (numberedMatch) {
                    const num = numberedMatch[1];
                    const text = cleanMarkdown(numberedMatch[2]);
                    return `<div class="wi-step numbered"><span class="step-number">${num}</span><span class="step-text">${text}</span></div>`;
                }
                
                // Regular content line
                const cleaned = cleanMarkdown(line);
                return `<div class="wi-step">${cleaned}</div>`;
            }
            
            // Parse the content into sections
            const sections = content.split(/\n(?=[A-Z][A-Z\s]+:)/);
            
            let html = `
                <div class="work-instruction">
                    <div class="wi-header">
                        ü§ñ AI-GENERATED WORK INSTRUCTION
                    </div>
                    
                    <div class="wi-caution">
                        <div class="wi-caution-icon">‚ö†Ô∏è</div>
                        <div>
                            <strong>CAUTION: AI-Generated Information</strong><br>
                            <span style="font-size: 13px; opacity: 0.95;">This information is AI-generated. User is responsible for referencing work instructions and manuals for accuracy. Contact supervisor to review prior to implementing any procedure.</span>
                        </div>
                    </div>
                    
                    <div class="wi-metadata">
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Production Line</span>
                            <span class="wi-metadata-value">${line}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Equipment</span>
                            <span class="wi-metadata-value">${machine}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Task/Procedure</span>
                            <span class="wi-metadata-value">${issue}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Generated</span>
                            <span class="wi-metadata-value">${new Date().toLocaleString()}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">AI Provider</span>
                            <span class="wi-metadata-value">${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'}</span>
                        </div>
                    </div>
            `;

            sections.forEach(section => {
                if (section.trim()) {
                    const lines = section.split('\n').filter(line => line.trim());
                    if (lines.length === 0) return;
                    
                    // Extract title (first line, remove asterisks and colon)
                    const title = lines[0].replace(/^\*\*/g, '').replace(/\*\*$/g, '').replace(':', '').trim();
                    const items = lines.slice(1);

                    html += `
                        <div class="wi-section">
                            <h4>${title}</h4>
                            <div class="wi-content">
                    `;

                    items.forEach(item => {
                        const formatted = formatLine(item);
                        if (formatted) {
                            html += formatted;
                        }
                    });

                    html += `
                            </div>
                        </div>
                    `;
                }
            });

            html += `
                    <div class="wi-actions">
                        <button onclick="window.print()" class="btn btn-primary">üñ®Ô∏è Print Instruction</button>
                        <button onclick="downloadWorkInstruction()" class="btn btn-info">üíæ Download as Text</button>
                    </div>
                </div>
            `;

            document.getElementById('generated-instruction').innerHTML = html;
        }

        function downloadWorkInstruction() {
            const content = document.getElementById('generated-instruction').innerText;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'work-instruction.txt';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // ====== AI ASSISTANCE FOR REPORT ISSUE ======
        async function askAIForAssistance() {
            // Gather all the current issue information
            const line = document.getElementById('line').value;
            const machine = document.getElementById('machine').value;
            const description = document.getElementById('description').value;
            
            if (!line || !machine || !description || currentActions.length === 0) {
                alert('Please fill in all issue details and add at least one action before requesting AI assistance.');
                return;
            }

            // Check configuration based on selected provider
            if (selectedProvider === 'gemini') {
                if (!geminiConfig.apiKey) {
                    showConfigurationRequired('Google Gemini', 'Get your free API key at ai.google.dev');
                    return;
                }
            } else if (selectedProvider === 'azure') {
                if (!azureConfig.endpoint || !azureConfig.apiKey) {
                    showConfigurationRequired('Azure OpenAI', 'Configure your Azure OpenAI credentials');
                    return;
                }
            }

            // Create a modal/div to show the AI response (we'll reuse the AI tab's display area)
            // First, create a dedicated display area if it doesn't exist
            let aiAssistanceDiv = document.getElementById('ai-assistance-display');
            if (!aiAssistanceDiv) {
                aiAssistanceDiv = document.createElement('div');
                aiAssistanceDiv.id = 'ai-assistance-display';
                aiAssistanceDiv.style.marginTop = '30px';
                document.getElementById('report-tab').appendChild(aiAssistanceDiv);
            }

            // Show loading state
            aiAssistanceDiv.innerHTML = `
                <div class="work-instruction">
                    <div class="wi-header">ü§ñ AI ANALYZING YOUR ISSUE</div>
                    <div style="padding: 60px 20px; text-align: center; background: white;">
                        <div class="loading-spinner"></div>
                        <p style="margin-top: 25px; color: #666; font-size: 15px;">
                            <strong>Analyzing your issue and actions taken...</strong><br>
                            <span style="font-size: 14px;">Consulting ${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'} AI for best course of action...</span>
                        </p>
                    </div>
                </div>
            `;

            // Scroll to the AI assistance display
            aiAssistanceDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            try {
                // Get manual info and file URIs using LINE-MACHINE key
                const manualKey = `${line}-${machine}`;
                const manualsArray = manualMappings[manualKey];
                let manualContext = '';
                let geminiFileUris = [];
                
                // Handle both old single-object format and new array format for migration
                const manuals = manualsArray && Array.isArray(manualsArray) ? manualsArray : 
                               (manualsArray ? [manualsArray] : []);
                
                if (manuals.length > 0) {
                    manualContext = '\n\nEquipment Manual References:\n';
                    manuals.forEach((manual, index) => {
                        manualContext += `${index + 1}. ${manual.name}\n   URL: ${manual.url}\n`;
                    });
                    
                    // Try to get Gemini file URIs (with auto-refresh if needed)
                    if (selectedProvider === 'gemini') {
                        try {
                            // Update loading message
                            aiAssistanceDiv.innerHTML = `
                                <div class="work-instruction">
                                    <div class="wi-header">ü§ñ AI ANALYZING YOUR ISSUE</div>
                                    <div style="padding: 60px 20px; text-align: center; background: white;">
                                        <div class="loading-spinner"></div>
                                        <p style="margin-top: 25px; color: #666; font-size: 15px;">
                                            <strong>Fetching ${manuals.length} equipment manual${manuals.length !== 1 ? 's' : ''} from Google Drive...</strong><br>
                                            <span style="font-size: 14px;">Reading manuals to provide accurate guidance...</span>
                                        </p>
                                    </div>
                                </div>
                            `;
                            
                            geminiFileUris = await getManualFileUris(manualKey, false);
                            
                            if (geminiFileUris.length > 0) {
                                manualContext += `\n(${geminiFileUris.length} PDF manual${geminiFileUris.length !== 1 ? 's' : ''} included and accessible to AI)`;
                            } else {
                                // PDFs were not available
                                throw new Error('Failed to obtain PDF file references');
                            }
                        } catch (error) {
                            console.error('Error fetching manuals:', error);
                            
                            // Show warning but continue (Ask AI is less critical than Work Instructions)
                            manualContext += `\n(Note: Could not access PDF manuals - ${error.message}. AI will provide general troubleshooting guidance.)`;
                            geminiFileUris = []; // Continue without PDFs
                        }
                    }
                }

                // Update loading message for AI analysis
                const manualCount = geminiFileUris.length;
                const manualNames = geminiFileUris.map(m => m.name).join(', ');
                aiAssistanceDiv.innerHTML = `
                    <div class="work-instruction">
                        <div class="wi-header">ü§ñ AI ANALYZING YOUR ISSUE</div>
                        <div style="padding: 60px 20px; text-align: center; background: white;">
                            <div class="loading-spinner"></div>
                            <p style="margin-top: 25px; color: #666; font-size: 15px;">
                                <strong>Analyzing issue and actions taken...</strong><br>
                                <span style="font-size: 14px;">Consulting ${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'} AI${manualCount > 0 ? ' with ' + manualCount + ' equipment manual' + (manualCount !== 1 ? 's' : '') : ''}...</span>
                            </p>
                        </div>
                    </div>
                `;

                // Get definitions context
                const definitionsContext = getDefinitionsContext();
                
                const hasManuals = manualCount > 0;

                // Format the actions taken
                let actionsText = '\n\nACTIONS ALREADY TAKEN:\n';
                currentActions.forEach((act, index) => {
                    actionsText += `${index + 1}. ${act.action}\n   Result: ${act.status}\n`;
                });

                // Create the prompt - focused on next best action, expert troubleshooting
                const prompt = `You are an expert manufacturing technician with years of experience troubleshooting equipment at baby wipes production facilities. You combine manual knowledge with practical troubleshooting logic to help solve problems.

${definitionsContext}
CURRENT SITUATION:
- Production Line: ${line}
- Machine/Equipment: ${machine}
- Issue Description: ${description}
${actionsText}${manualContext}

${hasManuals ? `
EQUIPMENT MANUALS AVAILABLE:
${manualCount} equipment manual${manualCount !== 1 ? 's are' : ' is'} attached (${manualNames}). Use them as references for:
- Known troubleshooting procedures
- Diagnostic steps
- Technical specifications
- Safety requirements

VISUAL CONTENT IN MANUALS:
The manuals include diagrams, photos, illustrations, and technical drawings. You MUST reference these when relevant:
- Troubleshooting flowcharts: "Refer to the diagnostic flowchart on Page X of [Manual Name]"
- Wiring diagrams: "Check connections shown in wiring diagram (Page X, [Manual Name])"
- Component photos: "The sensor location is shown in the photo on Page X of [Manual Name]"
- Exploded views: "Part #5 in the assembly diagram on Page X"
- Warning symbols: "Note the safety warning symbol shown in the manual"
- Measurement points: "Test points are indicated in Figure X"

When referencing manuals, cite as: [Source: Manual Name, Page X]
When referencing visual content, include: [See Figure/Diagram/Photo on Page X of Manual Name]
When information spans multiple manuals, integrate it and cite each source.
` : ''}

YOUR ROLE:
You are a skilled troubleshooting expert. Use:
1. **The manual** - for documented procedures, specifications, AND diagrams/illustrations
2. **The definitions** - for facility-specific context
3. **Your expertise** - apply logic and reasoning to the problem
4. **Pattern recognition** - analyze what the actions taken tell us

IMPORTANT: You should think beyond just what's in the manual. If the manual doesn't cover this exact scenario, use your troubleshooting logic and experience to provide the best course of action. Combine manual knowledge (including visual aids) with practical reasoning.

TASK: Based on the actions already taken and their results, recommend the BEST NEXT COURSE OF ACTION to resolve this issue.

PROVIDE:
1. **Analysis:** What do the actions taken tell us about the problem? Use logic to interpret the patterns.
2. **Root Cause:** What is most likely causing this issue? Consider both manual troubleshooting sections (including diagrams) and your technical reasoning.
3. **Recommended Next Steps:** 2-4 specific actions to take next. These should be:
   - Based on manual procedures when available (reference diagrams if helpful)
   - Based on sound troubleshooting logic when manual doesn't cover it
   - Practical and actionable
   - In logical diagnostic order
4. **Visual Aids:** If relevant diagrams, photos, or illustrations exist in the manual that would help the technician, list them with page numbers
5. **Safety Considerations:** Any safety warnings from manual (including warning symbols/images) or general safety practices for these actions
6. **References:** Cite relevant manual sections if applicable, or note if this is based on general troubleshooting principles

Be practical, logical, and helpful. Think like an experienced technician who knows how to diagnose problems systematically, not just someone reading from a manual. Use visual references to guide the technician to the right pages/diagrams.

Keep your response focused and actionable - help the technician understand the problem and know exactly what to try next.`;

                // Call the appropriate AI service
                let response;
                if (selectedProvider === 'gemini') {
                    response = await callGeminiAPI(prompt, geminiFileUris);
                } else {
                    response = await callGeminiAPI(prompt);
                }
                
                // Display the result
                displayAIAssistance(response, line, machine, description);

            } catch (error) {
                console.error('Error getting AI assistance:', error);
                aiAssistanceDiv.innerHTML = `
                    <div class="work-instruction">
                        <div class="wi-header" style="background: linear-gradient(135deg, #dc3545, #c82333);">‚ùå ERROR</div>
                        <div style="padding: 40px 25px; text-align: center; background: white;">
                            <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                            <h3 style="color: #dc3545; margin-bottom: 15px;">Failed to Get AI Assistance</h3>
                            <p style="color: #666; margin-bottom: 20px; font-size: 15px;">${error.message}</p>
                            <p style="color: #666; font-size: 14px;">
                                Please check your ${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'} configuration in the Setup tab.
                            </p>
                            <button onclick="switchTab('settings')" class="btn btn-primary" style="margin-top: 20px;">
                                Go to Setup
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        function displayAIAssistance(aiResponse, line, machine, issue) {
            const aiAssistanceDiv = document.getElementById('ai-assistance-display');
            
            // Helper function to clean up markdown formatting
            function cleanMarkdown(text) {
                // Remove leading asterisks and bullet points
                text = text.replace(/^\*\*(.+?)\*\*$/gm, '$1'); // Remove bold markers on whole lines
                text = text.replace(/^\*\s+/gm, ''); // Remove bullet points
                text = text.replace(/^[\*‚Ä¢-]\s*/gm, ''); // Remove asterisk, bullet, or dash bullets
                
                // Clean up inline formatting but keep citations
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>'); // Bold
                text = text.replace(/\[Source:/g, '<span class="citation">[Source:'); // Start citation
                text = text.replace(/\]/g, ']</span>'); // End citation
                
                return text.trim();
            }
            
            // Helper function to format different line types
            function formatLine(line) {
                line = line.trim();
                if (!line) return '';
                
                // Check if it's a numbered item (e.g., "1.", "2.", etc.)
                const numberedMatch = line.match(/^(\d+)\.\s*(.+)$/);
                if (numberedMatch) {
                    const num = numberedMatch[1];
                    const text = cleanMarkdown(numberedMatch[2]);
                    return `<div class="ai-step numbered"><span class="step-number">${num}</span><span class="step-text">${text}</span></div>`;
                }
                
                // Check if it's a section header (ALL CAPS followed by colon)
                if (line.match(/^[A-Z][A-Z\s]+:$/)) {
                    return `<h4 class="ai-section-header">${line.replace(':', '')}</h4>`;
                }
                
                // Regular content line
                const cleaned = cleanMarkdown(line);
                return `<div class="ai-content-line">${cleaned}</div>`;
            }
            
            // Parse and format the response
            const lines = aiResponse.split('\n').filter(l => l.trim());
            let formattedContent = '';
            
            lines.forEach(line => {
                const formatted = formatLine(line);
                if (formatted) {
                    formattedContent += formatted;
                }
            });
            
            let html = `
                <div class="work-instruction">
                    <div class="wi-header">ü§ñ AI RECOMMENDED COURSE OF ACTION</div>
                    
                    <div class="wi-caution">
                        <div class="wi-caution-icon">‚ö†Ô∏è</div>
                        <div>
                            <strong>CAUTION: AI-Generated Recommendation</strong><br>
                            <span style="font-size: 13px; opacity: 0.95;">Contact supervisor to review prior to implementing these recommendations. Always follow company safety protocols.</span>
                        </div>
                    </div>
                    
                    <div class="wi-metadata">
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Production Line</span>
                            <span class="wi-metadata-value">${line}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Equipment</span>
                            <span class="wi-metadata-value">${machine}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Issue</span>
                            <span class="wi-metadata-value">${issue}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">Generated</span>
                            <span class="wi-metadata-value">${new Date().toLocaleString()}</span>
                        </div>
                        <div class="wi-metadata-item">
                            <span class="wi-metadata-label">AI Provider</span>
                            <span class="wi-metadata-value">${selectedProvider === 'gemini' ? 'Google Gemini' : 'Azure OpenAI'}</span>
                        </div>
                    </div>
                    
                    <div class="wi-section">
                        <div class="ai-assistance-content">
                            ${formattedContent}
                        </div>
                    </div>
                    
                    <div class="wi-actions">
                        <button onclick="window.print()" class="btn btn-primary">üñ®Ô∏è Print Recommendation</button>
                        <button onclick="downloadAIAssistance()" class="btn btn-info">üíæ Download as Text</button>
                        <button onclick="document.getElementById('ai-assistance-display').innerHTML = ''" class="btn btn-warning">‚úñÔ∏è Close</button>
                    </div>
                </div>
            `;

            aiAssistanceDiv.innerHTML = html;
        }

        function downloadAIAssistance() {
            const content = document.getElementById('ai-assistance-display').innerText;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-assistance-recommendation.txt';
            a.click();
            window.URL.revokeObjectURL(url);
        }


        // ====== EASTER EGG ======
        function robotEasterEgg() {
            const columnA = [
                "Ouch!",
                "Hey!",
                "Boop!",
                "Woah!",
                "Beep boop!",
                "Uh oh!",
                "Yikes!",
                "Haha!"
            ];

            const columnB = [
                "That felt like",
                "You just zapped",
                "My circuits are",
                "That really",
                "I'm going to",
                "That tickled",
                "Did you just",
                "My processor is"
            ];

            const columnC = [
                "a giant mosquito.",
                "my metal nose.",
                "doing a silly dance.",
                "woke up my brain.",
                "think about pizza now.",
                "my secret power button.",
                "pop a memory bubble?",
                "giggling really loud."
            ];

            // Pick random items from each column
            const randomA = columnA[Math.floor(Math.random() * columnA.length)];
            const randomB = columnB[Math.floor(Math.random() * columnB.length)];
            const randomC = columnC[Math.floor(Math.random() * columnC.length)];

            // Combine them into a funny phrase
            const funnyPhrase = `${randomA} ${randomB} ${randomC}`;

            // Display in a fun alert
            alert('ü§ñ ' + funnyPhrase);
        }

        // ====== CLOUD SYNC VERIFICATION ======
        async function verifyCloudSync() {
            const resultDiv = document.getElementById('sync-verification-result');
            resultDiv.innerHTML = '<p style="color: #666;">üîç Checking Google Sheets...</p>';
            
            try {
                const response = await fetch(GOOGLE_SCRIPT_URL + '?action=load');
                const data = await response.json();
                
                if (data.success) {
                    let html = '<div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 8px; padding: 15px; margin-top: 10px;">';
                    html += '<h4 style="color: #2e7d32; margin-bottom: 10px;">‚úì Cloud Connection Successful</h4>';
                    
                    // Show what's stored
                    if (data.aiConfigs && data.aiConfigs.manualMappings) {
                        const cloudMappings = data.aiConfigs.manualMappings;
                        const mappingCount = Object.keys(cloudMappings).length;
                        
                        html += `<p><strong>Manual Mappings in Google Sheets:</strong> ${mappingCount} mapping${mappingCount !== 1 ? 's' : ''}</p>`;
                        
                        if (mappingCount > 0) {
                            html += '<ul style="margin: 10px 0; padding-left: 20px;">';
                            for (const [key, info] of Object.entries(cloudMappings)) {
                                const [line, machine] = key.split('-', 2);
                                html += `<li>${line} - ${machine}: ${info.name}</li>`;
                            }
                            html += '</ul>';
                        }
                        
                        // Compare with local
                        const localCount = Object.keys(manualMappings).length;
                        if (localCount !== mappingCount) {
                            html += `<p style="color: #ff9800; margin-top: 10px;"><strong>‚ö†Ô∏è Warning:</strong> Local storage has ${localCount} mapping${localCount !== 1 ? 's' : ''}, but cloud has ${mappingCount}. They may be out of sync!</p>`;
                        } else {
                            html += '<p style="color: #4caf50; margin-top: 10px;">‚úì Local and cloud are in sync!</p>';
                        }
                    } else {
                        html += '<p style="color: #ff9800;">‚ö†Ô∏è No manual mappings found in Google Sheets</p>';
                    }
                    
                    html += '</div>';
                    resultDiv.innerHTML = html;
                } else {
                    throw new Error(data.message || 'Unknown error');
                }
            } catch (error) {
                resultDiv.innerHTML = `
                    <div style="background: #ffebee; border: 1px solid #f44336; border-radius: 8px; padding: 15px; margin-top: 10px;">
                        <h4 style="color: #c62828;">‚ùå Cloud Connection Failed</h4>
                        <p style="color: #666; margin-top: 10px;">Error: ${error.message}</p>
                        <p style="color: #666; margin-top: 10px;"><strong>Possible causes:</strong></p>
                        <ul style="margin: 10px 0; padding-left: 20px; color: #666;">
                            <li>Google Apps Script URL not set correctly</li>
                            <li>Script not deployed as web app</li>
                            <li>Script permissions not set to "Anyone"</li>
                            <li>Network connection issue</li>
                        </ul>
                        <p style="color: #666; margin-top: 10px;">Your manual mappings are saved locally but won't sync to other devices until this is fixed.</p>
                    </div>
                `;
            }
        }

        async function forceResyncAll() {
            if (!confirm('This will push all your current local manual mappings to Google Sheets.\n\nContinue?')) {
                return;
            }
            
            const resultDiv = document.getElementById('sync-verification-result');
            resultDiv.innerHTML = '<p style="color: #666;">üîÑ Forcing re-sync...</p>';
            
            try {
                await syncAIConfigsToCloud();
                
                // Verify it worked
                setTimeout(async () => {
                    await verifyCloudSync();
                }, 2000);
            } catch (error) {
                resultDiv.innerHTML = `
                    <div style="background: #ffebee; border: 1px solid #f44336; border-radius: 8px; padding: 15px; margin-top: 10px;">
                        <h4 style="color: #c62828;">‚ùå Re-sync Failed</h4>
                        <p style="color: #666; margin-top: 10px;">Error: ${error.message}</p>
                    </div>
                `;
            }
        }
    </script>
</body>
</html>
